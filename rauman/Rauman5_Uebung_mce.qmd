---
date: 2022-12-12
lesson: RaumAn5
thema: Multi-Criteria Evaluation (MCE)
index: 1
---

# Rauman 5: Ãœbung

{{< include /../_before-article.qmd >}}

The following exercise may seem familiar to some of you, if you have attended the bachelor program. This MCE was already conducted in the bachelor module "GIS" by using ArcGIS Pro and its ModelBuilder (see @fig-mce-process).

![MCE Process](images/mce_process.png){#fig-mce-process}

The goal of this exercise is to do the same MCE by just using R. We will mainly use functions from the R packages [sf](https://cran.r-project.org/web/packages/sf/sf.pdf) and [raster](https://cran.r-project.org/web/packages/raster/raster.pdf). Please have a look at the process model (see @fig-mce-process) that was created in ArcGIS Pro and try to figure out which functions in the two R packages correspond to the ones in the model. You will see that there are some similar functions available, but for some calculations a different approach is needed.

## Exercises 1: Load and view data

```{r}
#| results: asis
#| echo: false
#| purl: false
#| message: false
knitr::opts_chunk$set(echo = TRUE)

datasets <- data.frame(
  datasets = c("dhm25m.tif", "eis25m.tif", "wind25m.tif", "Bewohnte_Flaeche.gpkg", "Nationale_Schutzgebiete.gpkg", "Seeflaechen.gpkg", "Strassen.gpkg", "Untersuchungsgebiet_Schwyz.gpkg", "Waldgebiete.gpkg"),
  description = c("Terrain model (m)", "Icing frequency (days/year)", "Average wind speed (dm/s) ", "Settlements (incl. buffer 200m)", "National protection areas", "Lake areas", "Streets", "Study area, canton of Schwyz", "Forest areas"),
  type = c("Raster", "Raster", "Raster", "Geopackage", "Geopackage", "Geopackage", "Geopackage", "Geopackage", "Geopackage"),
  res = c("25m", "25m", "25m", "", "", "", "", "", ""),
  geometry = c("", "", "", "Polygon", "Polygon", "Polygon", "Line", "Polygon", "Polygon"),
  crs = c("CH1903/LV03", "CH1903/LV03", "CH1903/LV03", "CH1903/LV03", "CH1903/LV03", "CH1903/LV03", "CH1903/LV03", "CH1903/LV03", "CH1903/LV03"),
  exclusion_area = c("No", "No", "No", "(Yes)/Distance", "(Yes)/Distance", "Yes", " No/Distance   ", "No", "(Yes)/Distance")
)

library(stringr)
library(kableExtra)
library(dplyr)
```

```{r}
#| label: datatable
#| results: asis
#| echo: false
#| purl: false
#| label: tbl-data
#| tbl-cap: Data used in this study
datasets %>%
  mutate(
    datasets = kableExtra::cell_spec(datasets, "html")
  ) %>%
  kableExtra::kable(caption = "Data used in this study (click on the link to download)",escape = FALSE) %>% 
  kable_styling(latex_options=c("scale_down", "HOLD_position"))
```

The raster data can be loaded by using the function `terra::rast` and the vector data with `sf::read_sf`. View the available data layers (see @tbl-data) and plot them in an appealing way. For visualization you can use the functions `plot` for raster data and `ggplot` for vector data.

<!-- Some data sets exceed the boundaries of the study area. Use the function `crop`  on raster data sets and `st_intersection` for sf/vector data to extract the relevant areas. -->

We will use the following packages in this exercise:

```{r}
#| message: false
library(sf)
library(terra)
library(dplyr)
library(tmap)
```

```{r}
#| label: solutionEx1
#| echo: false
#| message: false
#| warning: false
#| include: false
#Vector data
kt_schwyz <- read_sf("data/Untersuchungsgebiet_Schwyz.gpkg")
settlements <- read_sf("data/Bewohnte_Flaeche.gpkg")
forests <- read_sf("data/Waldgebiete.gpkg")
protected_areas <- read_sf("data/Nationale_Schutzgebiete.gpkg")
lakes <- read_sf("data/Seeflaechen.gpkg")
streets <- read_sf("data/Strassen.gpkg") %>% st_intersection(kt_schwyz) #intersect with study area

#Raster data
eis25m <- rast("data/eis25m.tif")
dhm25m <- rast("data/dhm25m.tif")
wind25m <- rast("data/wind25m.tif")
```

```{r}
#| message: false
#| warning: false
#| include: false
#Plot vector data
tm_shape(lakes) + tm_polygons(col = "dodgerblue3") +
  tm_shape(streets) + tm_lines(col = "gray18") +
  tm_shape(forests) + tm_polygons(col = "darkseagreen4", alpha = 0.5) +
  tm_shape(settlements) + tm_polygons(col = "gray",alpha = 0.5)
```

```{r}
#| message: false
#| warning: false
#| include: false
tm_shape(dhm25m) + tm_raster(style = "cont") + tm_shape(kt_schwyz) + tm_borders()
tm_shape(eis25m) + tm_raster(style = "cont") + tm_shape(kt_schwyz) + tm_borders()
tm_shape(wind25m) + tm_raster(style = "cont") + tm_shape(kt_schwyz) + tm_borders()
```

## Exercise 2: Merge exclusion criteria

Merge the exclusion criteria settlement areas, national protected areas, lake areas and forest areas. These vector data sets are structured as data frames and therefore can be merged by simply combining them. Keep in mind that the data frames have different sizes. Additionally, we need to create a raster out of the newly created vector data set (exclusion area). For that you can use the function `rasterize`. The output should be a raster with 0 and 1, where the fields of the exclusion area have values of 0 and the remaining fields have values of 1 (see Figure \ref(fig:figrasterizeexclusioncriteria)).
  
* ***Tip**: To achieve a raster with only 0 and 1 use the `rasterize` options field = 0 and background = 1.*
* ***Tip**: In order to rasterize vector data, you need to create an empty raster beforehand. This raster should have the same boundaries (extent), resolution and coordinate system (crs) as the other raster sets. Use the following code to do so.*
  
```{r}
#| label: create_empty_raster
r <- terra::rast(ext(kt_schwyz), 
          resolution = c(250, 250), 
          crs = "EPSG:21781")
```
  
![](images/exclusion_areas.png){width=50%}

```{r}
#| label: solutionEx2
#| echo: false
#| message: false
#| warning: false
#| include: false
#Merge exclusion area
exclusion_areas <- dplyr::bind_rows(settlements, forests, protected_areas, lakes)

#create raster
r <- terra::rast(ext(kt_schwyz), 
          resolution = c(250, 250), 
          crs = "EPSG:21781")

raster_exclusion_areas <- rasterize(vect(exclusion_areas), r,
                       field = 0, background = 1) %>% crop(kt_schwyz)
plot(raster_exclusion_areas, main="Exclusion area", axes=FALSE, legend=FALSE, col=terrain.colors(2))
```

## Exercise 3: Calculate slope

Next, calculate the slope in degrees based on the terrain model (dhm25m). The terra package gives you a very helpful function called `terrain`. 

***Tip**: When using the terrain function use the following options: v="slope", unit="degrees", neighbors=8.*

![](images/slope.png){width=50%}

```{r}
#| label: solutionEx3
#| echo: false
#| message: false
#| warning: false
#| include: false
slope <- terra::terrain(dhm25m, v="slope",unit="degrees", neighbors=8)
slope_250 <- slope %>% aggregate(.,fact = 10)
plot(slope_250, main="Slope", axes=FALSE)
```

## Exercise 4: Calculate distances to criteria

Within the evaluation of suitable sites for wind turbines, the distance to roads, forest areas, national protected areas and inhabited areas are relevant. Depending on the criteria, a short or long distance has a positive influence on the evaluation of potential sites. For this purpose, perform a distance analysis with the selected criteria raster layers. Use the raster function `distance` for this calculation. 

* ***Tip**: In order to perform the `distance` function, you need to `rasterize` the criteria as well. You can use the same command as in exercise 2 but use only option field = 1.*
* ***Tip**: Use the `crop` function again to get only relevant data in the study area.*

![](images/d_to_settlements.png){width=50%}

```{r}
#| label: solutionEx4
#| echo: false
#| message: false
#| warning: false
#| include: false
#create raster layers from vector 
raster_settlements <- terra::rasterize(vect(settlements), r, field = 1)
raster_protected_areas <- terra::rasterize(vect(protected_areas), r, field = 1) 
raster_forests <- terra::rasterize(vect(forests), r, field = 1) 
raster_streets <- terra::rasterize(vect(streets$geom), r, field = 1)

#calculate euclidean distances
settlements_ed <- distance(raster_settlements) %>% raster::raster() %>% raster::mask(kt_schwyz) %>% terra::rast()
protected_areas_ed <- distance(raster_protected_areas) %>% raster::raster() %>% raster::mask(kt_schwyz) %>% terra::rast()
forests_ed <- distance(raster_forests) %>% raster::raster() %>% raster::mask(kt_schwyz) %>% terra::rast()
streets_ed <- distance(raster_streets) %>% raster::raster() %>% raster::mask(kt_schwyz) %>% terra::rast()
```

## Exercise 5: Standardize and grade criteria (grading)

The data layers slope, wind speed, icing frequency and the in exercise 4 calculated distance layers have different units (dm/s, degrees, d/yr and m). These units can't be directly calculated with each other. Therefore, the different layers need to be operationalized by performing a linear grading. The linear grading is done by using the function `reclassify`. Use the  standards for the reclassification in Figure \ref(fig:figreclassify).

* ***Tip**: Keep in mind the min and max values of each raster layer.*
* ***Tip**: Here is an example code to reclassify the distances to settlements.*

```{r}
#| label: examplereclassifysettlements
settlements_max <- minmax(settlements_ed)[2]

reclass_settlements <- c(0,80,0,
                        80,160,0.1,
                        160,240,0.2,
                        240,320,0.3,
                        320,400,0.4,
                        400,480,0.5,
                        480,560,0.6,
                        560,640,0.7,
                        640,720,0.8,
                        720,800,0.9,
                        800,settlements_max,1.0) %>% matrix(ncol = 3, byrow = TRUE)
reclass_settlements_ed <- terra::classify(settlements_ed, reclass_settlements)
```

::: {#fig-mce-reclassify layout-ncol=2}
![](images/mce_reclassify_1.png)

![](images/mce_reclassify_2.png)

MCE Reclassify
:::

![](images/d_to_settlements_reclassified.png){width=50%}

```{r}
#| label: solutionEx5
#| echo: false
#| message: false
#| warning: false
#| include: false
#### reclassify wind
wind250m <- wind25m %>% aggregate(.,fact = 10)
wind_max <- minmax(wind250m)[2]
reclass_wind_m <- c(0,35,0,
                      35,40,0.1,
                      40,45,0.2,
                      45,50,0.3,
                      50,55,0.4,
                      55,60,0.5,
                      60,65,0.6,
                      65,70,0.7,
                      70,75,0.8,
                      75,wind_max,0.9) %>% matrix(ncol = 3, byrow = TRUE)
reclass_wind <- classify(wind250m, reclass_wind_m)
plot(reclass_wind, main="Average wind speed (reclassified)", axes=FALSE)

#### reclassify ice    
eis250m <- eis25m %>% aggregate(.,fact = 10) ## lowering the resolution
eis_max <- minmax(eis250m)[2]
reclass_ice_m <- c(0,6,1,
                     6,12,0.9,
                     12,18,0.8,
                     18,24,0.7,
                     24,30,0.6,
                     30,36,0.5,
                     36,eis_max,0.4) %>% matrix(ncol = 3, byrow = TRUE)
reclass_ice <- classify(eis250m, reclass_ice_m)
plot(reclass_ice, main="Icing frequency (reclassified)", axes=FALSE)

#### reclassify slope
slope250m <- slope %>% aggregate(.,fact = 10) ## lowering the resolution
slope_max <- minmax(slope250m)[2]
reclass_slope_m <- c(0,2,1,
                       2,4,0.9,
                       4,6,0.8,
                       6,8,0.7,
                       8,10,0.6,
                       10,12,0.5,
                       12,14,0.4,
                       14,16,0.3,
                       16,18,0.2,
                       18,20,0.1,
                       20,slope_max,0) %>% matrix(ncol = 3, byrow = TRUE)
reclass_slope <- classify(slope250m, reclass_slope_m)
plot(reclass_slope, main="Slope (reclassified)", axes=FALSE)

#### reclassify settlements 
settlements_max <- minmax(settlements_ed)[2]
reclass_settlements <- c(0,80,0,
                             80,160,0.1,
                             160,240,0.2,
                             240,320,0.3,
                             320,400,0.4,
                             400,480,0.5,
                             480,560,0.6,
                             560,640,0.7,
                             640,720,0.8,
                             720,800,0.9,
                             800,settlements_max,1.0) %>% matrix(ncol = 3, byrow = TRUE)
reclass_settlements_ed <- classify(settlements_ed, reclass_settlements)
plot(reclass_settlements_ed, main="Distance to settlements (reclassified)", axes=FALSE)

#### reclassify protected areas
protected_areas_max <- minmax(protected_areas_ed)[2]
reclass_protected_areas <- c(0,50,0,
                                 50,100,0.1,
                                 100,150,0.2,
                                 150,200,0.3,
                                 200,250,0.4,
                                 250,300,0.5,
                                 300,350,0.6,
                                 350,400,0.7,
                                 400,450,0.8,
                                 450,500,0.9,
                                 500,protected_areas_max,1.0) %>% matrix(ncol = 3, byrow = TRUE)
reclass_protected_areas_ed <- classify(protected_areas_ed, reclass_protected_areas)
plot(reclass_protected_areas_ed, main="Distance to protected areas (reclassified)", axes=FALSE)

#### reclassify forest area 
forests_max <- minmax(forests_ed)[2]
reclass_forests <- c(0,10,0,
                         10,20,0.1,
                         20,30,0.2,
                         30,40,0.3,
                         40,50,0.4,
                         50,60,0.5,
                         60,70,0.6,
                         70,80,0.7,
                         80,90,0.8,
                         90,100,0.9,
                         100,forests_max,1.0) %>% matrix(ncol = 3, byrow = TRUE)
reclass_forests_ed <- classify(forests_ed, reclass_forests)
plot(reclass_forests_ed, main="Distance to forest areas (reclassified)", axes=FALSE)

#### reclassify streets   
streets_max <- minmax(streets_ed)[2]
reclass_streets <- c(0,250,1.0,
                     250,500,0.9,
                     500,750,0.8,
                     750,1000,0.7,
                     1000,1250,0.6,
                     1250,1500,0.5,
                     1500,1750,0.4,
                     1750,2000,0.3,
                     2000,2250,0.2,
                     2250,2500,0.1,
                     2500,streets_max,0) %>% matrix(ncol = 3, byrow = TRUE)
reclass_streets_ed <- classify(streets_ed, reclass_streets)
plot(reclass_streets_ed, main="Distance to streets (reclassified)", axes=FALSE)
```

## Exercise 6: Weighting criteria with AHP

Perform an AHP to weight the criteria underlying the MCE. First compare the criteria in pairs, and then calculate the weights - as you have learned in last week's lesson. In the end you should have a list of 7 weights as shown below.

***Tip**: Check exercise 2 and 3 from last week's session. Use the prepared R code to create your ahp matrix.*

          Wind       Streets          Ice    Settlements       Forest         Slope  Protected areas 
    0.33862692    0.09816760    0.06166626    0.24969460    0.03515759    0.18043000      0.03625702 
  
```{r}
#| label: ahp_mce
ahp_matrix <- c(
  1, 0, 0, 0, 0, 0, 0, #Wind
  0, 1, 0, 0, 0, 0, 0, #Distance to streets
  0, 0, 1, 0, 0, 0, 0, #Ice
  0, 0, 0, 1, 0, 0, 0, #Distance to settlements
  0, 0, 0, 0, 1, 0, 0, #Distance to forests
  0, 0, 0, 0, 0, 1, 0, #Slope
  0, 0, 0, 0, 0, 0, 1  #Distance to protected areas
) %>% matrix(ncol = 7, byrow = TRUE)
```

```{r}
#| label: solutionEx6
#| echo: false
#| message: false
#| warning: false
#| include: false
#create AHP
ahp_matrix <- c(
  1,   6,   7,   3,   7, 4,   5, #Wind
  1/6, 1,   2,   1/5, 3, 1/5, 3, #Distance to streets
  1/7, 1/2, 1,   1/6, 2, 1/5, 2, #Ice
  1/3, 5,   6,   1,   5, 3,   4, #Distance to settlements
  1/7, 1/3, 1/2, 1/5, 1, 1/4, 1, #Distance to forests
  1/4, 5,   3,   1/3, 4, 1,   4, #Slope
  1/5, 1/3, 1/2, 1/4, 1, 1/4, 1  #Distance to protected areas
) %>% matrix(ncol = 7, byrow = TRUE)
colnames(ahp_matrix) <- c("Wind", "Streets", "Ice", "Settlements", "Forest", "Slope", "Protected areas")
rownames(ahp_matrix) <- c("Wind", "Streets", "Ice", "Settlements", "Forest", "Slope", "Protected areas")

#Normalization of matrix & weighting of criteria
weights <- rowSums(ahp_matrix) #add row sum
```

## Exercise 7: Weighted Overlay

The linearly ranked criteria (Exercise 5) are now to be combined with each other, taking into account the weighting determined using the AHP (Exercise 6). This weighted overlay can be performed by using raster calculations and simply multiplying each criteria with its weight and adding them together (see @fig-weighted-overlay).

* ***Tip**: As the raster sets have slightly different origins, increase the tolerance by using rasterOptions(tolerance = 0.5).*
* ***Tip**: Also keep in mind the order of the weights in your list when doing the multiplication.*

![Weighted Overlay](images/weighted_overlay.png){#fig-weighted-overlay width=50%}

```{r}
#| label: solutionEx7
#| echo: false
#| message: false
#| warning: false
#| include: false
# rasterOptions(tolerance = 0.5) #raster sets have different origins, increase tolerance

wind_f <- (reclass_wind * weights[1])
streets_f <- (reclass_streets_ed * weights[2])
eis_f <- (reclass_ice * weights[3]) 
settlements_f <- (reclass_settlements_ed * weights[4])
forests_f <- (reclass_forests_ed * weights[5])
slope_f <- (reclass_slope * weights[6])
protected_areas_f <- (reclass_protected_areas_ed * weights[7])

weighted_overlay <- terra::merge(streets_f,eis_f,settlements_f,forests_f,
                                  slope_f,protected_areas_f,wind_f)

# Transforming all the layer from SpatRaster class to RasterLayer class, so
# we can perform the raster multiplication operation

streets_R <- streets_f %>% raster::raster()
eis_R <- eis_f %>% raster::raster()
settlements_R <- settlements_f %>% raster::raster()
forests_R <- forests_f %>% raster::raster()
slope_R <- slope_f %>% raster::raster()
protected_areas_R <- protected_areas_f %>% raster::raster()
wind_R <- wind_f %>% raster::raster()

weighted_overlay <- streets_R*eis_R*settlements_R*forests_R*slope_R*protected_areas_R*wind_R

plot(weighted_overlay, main="Weighted overlay with all criteria", axes=FALSE, legend=F)
```

## Exercise 8: Intersecting potential areas with exclusion criteria

By simply multiplying the exclusion layer (result from exercise 2) with the weighted overlay layer (result from exercise 7) we are excluding all areas with value 0 (exclusion areas) and keeping all other areas with value 1 (e.g. 0x3=0, 1x3=3). As a conclusion of the study, create a final plot of the potential areas for wind power plants in the canton of Schwyz (like @fig-potential-sites). Furthermore, discuss the results obtained and determine three possible locations within which concrete planning of wind power plants would be possible.

![Potential Sites](images/potential_sites.png){#fig-potential-sites}

```{r}
#| label: solutionEx8
#| echo: false
#| message: false
#| warning: false
#| include: false
# Transforming  the layer depicting the exclusion areas from SpatRaster class to RasterLayer class, so we can perform the final raster multiplication operation
raster_exclusion_areas <- raster_exclusion_areas %>% raster::raster()
final_model <- weighted_overlay * raster_exclusion_areas
plot(final_model, main="Potential sites for wind power plants in Kt. Schwyz", axes=FALSE, legend=F)
```

## MusterlÃ¶sung

[R-Code](Uebung_mce.R) 
```{r}
#| echo: false
#| message: false
#| results: asis
#| purl: false
#| eval: false
#distill::mypurl() # for some reason (chunk names) this code does not run. debug at some point
```
