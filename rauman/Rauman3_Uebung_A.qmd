---
date: 2022-12-05
lesson: RaumAn3
thema: Morans I
index: 1
execute: 
  echo: false
  include: true
  eval: false
---

# Rauman 3: Übung


Heute berechnen wir Morans $I$, also ein globales Mass für Autokorrelation, für die Abstimmungsresultate der Zweitwohnungsinitiative. Dieser berechnete Wert beschreibt, ob Kantone, die nahe beieinander liegen ähnliche Abstimmungswerte haben. Hierfür verwenden wir folgenden Datensatz:


- [zweitwohnungsinitiative.gpkg](https://moodle.zhaw.ch/mod/resource/view.php?id=602283)

```{r}
#| echo: true
library(dplyr)
library(ggplot2)
library(sf)

# Das Geopackage beinhaltet 3 Layers (siehe st_layers("zweitwohnungsinitiative.gpkg"))
# In jedem Layer sind die Abstimmungsresultate auf eine andere politische Ebene
# aggregiert. Wir started mit der Aggregationsstufe "kanton"
zweitwohnung_kanton <- read_sf("datasets/rauman/zweitwohnungsinitiative.gpkg", "kanton")
```

```{r}
#| fig-cap: Was für einen Autokorrelationswert würdest du erwarten? Eher 1 (hohe Autokorrelation, beieinanderliegende Kantone haben ähnliche Werte) oder eher -1 (beieinanderliegende Kantone haben sehr unterschiedliche Werte) oder eher 0 (gar keine Autokorrelation)

p <- ggplot(zweitwohnung_kanton) +
  geom_sf(aes(fill = ja_in_percent), colour = "white",lwd = 0.2) +
  scale_fill_gradientn(colours = RColorBrewer::brewer.pal(11, "RdYlGn"), limits = c(0,1))  +
  theme(legend.position = "bottom")

p
```


Für die Berechnung von Morans $I$ benutzen wir kein externes Package, sondern erarbeiten uns alles selber, basierend auf der Formel von Moran's $I$: 

$$I = \frac{n}{\sum_{i=1}^n (y_i - \bar{y})^2} \times \frac{\sum_{i=1}^n \sum_{j=1}^n w_{ij}(y_i - \bar{y})(y_j - \bar{y})}{\sum_{i=1}^n \sum_{j=1}^n w_{ij}}$$


wobei:

- $n$ der Anzahl räumlichen Objekte (hier: Kantone) in unserem Datensatz entspricht
- $y$ der untersuchten Variabel entspricht (hier: Ja-Anteil in %)
- $\bar{y}$ dem Mittelwert der untersuchten Variabel entspricht
- $w_{ij}$ der Gewichtsmatrix entspricht


$$I =\frac{\text{z1}}{\text{n1}}\times\frac{\text{z2}}{\text{n2}}$$


Diese sieht sehr beeindruckend aus, aber wenn wir die Formel in ihre Einzelbestandteile aufteilen, sehen wir, dass diese in sich gar nicht so komplex sind. So teilen wir ein vermeintlich komplexes Problem in überschaubare Einzelteile. Dieses Vorgehen illustriert ausserdem sehr schön ein generelles Data Science Prinzip. Divide and Conquer - Teile und Herrsche: Teile ein komplexes Problem in kleinere, beherrschbare Unterprobleme. 

## Aufgabe 1: Morans $I$ für Kantone


### Berechnung von $n$

$$I = \frac{\color{red}n}{\sum_{i=1}^{\color{red}n} (y_i - \bar{y})^2} \times \frac{\sum_{i=1}^n \sum_{j=1}^{\color{red}n}  w_{ij}(y_i - \bar{y})(y_j - \bar{y})}{\sum_{i=1}^n \sum_{j=1}^{\color{red}n}  w_{ij}}$$


Beginnen wir mit der Variabel $n$. Dies ist lediglich die Anzahl Messwerte in unserem Datensatz, also die Anzahl Kantone. 

```{r}
#| echo: true
n <- nrow(zweitwohnung_kanton)
n
```

### Abweichung vom Mittelwert 

$$I = \frac{n}{\color{red}\sum_{i=1}^n (y_i - \bar{y})^2} \times \frac{{\color{orange}\sum_{i=1}^n} \sum_{j=1}^n w_{ij}{\color{orange}(y_i - \bar{y})(y_j - \bar{y})}}{\sum_{i=1}^n \sum_{j=1}^n w_{ij}}$$


Der Nenner des ersten Bruches entspricht fast der Berechnung der Varianz. Wir berechnen für jeden Messwert die Differenz zum Durchschnitt ($y_i - \bar{y}$), quadrieren diese einzelwerte und nehmen davon die Summe. 

```{r}
#| echo: true
# Die Werte aller Kantone in einer Variabel abspeichern
y <- zweitwohnung_kanton$ja_in_percent

# Der Durchschnittswert aller Kantone berechnen
ybar <- mean(y, na.rm = TRUE)

# Von jedem Wert den Durchschnittswert abziehen:
dy <- y - ybar

# Die Differenzen quadrieren
dy_2 <- dy^2

# Und davon die Summe bilden:
dy_sum <- sum(dy_2, na.rm = TRUE)
```


<!--
#### Auflösung (Bruch 1)

Beschliessen wir die Bearbeitung des ersten Bruchs indem wir den Zähler durch den Nennen dividieren:  `n` durch `dy_sum`.

```{r}
#| echo: true
vr <- n/dy_sum
```

-->

<!--
### Bruch 2



Hier berechnen wir die Summe aller Gewichte sowie die gewichteten Covarianzen. Wir betrachten immer Messwertpaare, sprich paarweise Vergleiche zweier Raumeinheiten (hier Kantone). Deshalb haben die zwei Summenzeichen die beiden unterschiedlichen Laufvariablen ($i$ und $j$). Solche paarweise Vergleiche von Werten mit allen anderen Werten können wir elegant mit Kreuzmatrizen abbilden. In der Kreuzmatrix vergleichen wir jeden Messwert mit allen anderen Messwerten. Dabei gibt es zwei Kreuzmatrizen: ($w_{ij}$ ist die erste Kreuzmatrix, $(y_i - \bar{y})(y_j - \bar{y})$ ist die zweite Kreuzmatrix). 

-->

### Kreuzmatrix

$$I = \frac{n}{\sum_{i=1}^n (y_i - \bar{y})^2} \times \frac{{\color{red}\sum_{i=1}^n \sum_{j=1}^n} w_{ij}(y_i - \bar{y})(y_j - \bar{y})}{{\color{red}\sum_{i=1}^n \sum_{j=1}^n}^n w_{ij}}$$


Während das alleinstehende Summenzeichen ($\sum$) noch einigermassen nachvollziehbar ist, sind die doppelten Summenzeichen etwas verwirrlich und braucht etwas Erklärung. $\sum_{i=1}^n \sum_{j=1}^n$ stellt eine Kreuzmatrix dar, in dem jeder Wert mit jedem anderen Wert verglichen wird. Also das Abstimmungsresultat des Kantons Zürich wird mit allen anderen 25 Kantonen verglichen, das gleiche gilt für den Kanton Bern, Basel usw. Die nachfolgenden Berechnungen müssen wir also in dieser Kreuzmatrix durchführen. 

### Räumliche Gewichtung

$$I = \frac{n}{\sum_{i=1}^n (y_i - \bar{y})^2} \times \frac{\sum_{i=1}^n \sum_{j=1}^n {\color{red}w_{ij}}(y_i - \bar{y})(y_j - \bar{y})}{\sum_{i=1}^n \sum_{j=1}^n {\color{red}w_{ij}}}$$


$w_{ij}$, beschreibt die räumlichen Gewichte aller Kantone. Sind die Kantone räumlich nah, dann gilt ein Gewicht von 1, sind sie räumlich weit entfernt, gilt ein Gewicht von 0. Dies entspricht dem "Schalter" aus der Vorlesung. Dabei ist die Definition von "räumlich nah" nicht festgelegt. Denkbar wären zum Beispiel folgende Optionen:

- Die Kantone müssen sich berühren: `st_touches()`
- Die Kantone müssen innerhalb einer bestimmten Distanz zueinander liegen: `st_is_within_distance()`

Egal für welche Variante Ihr Euch entscheidet, setzt `sparse = FALSE` damit eine Kreuzmatrix erstellt wird. (Lasst Euch nicht davon beirren, dass wir nun `TRUE` und `FALSE` statt `1` und `0` haben. In R sind `TRUE` und `1` äquivalent, sowie auch `FALSE` und `0`). 

```{r}
#| echo: true

# st_touches berechnet eine Kreuzmatrix aller Objekte
w <- st_touches(zweitwohnung_kanton, sparse = FALSE)

# Schauen wir uns die ersten 5 Reihen und Zeilen an
w[1:5, 1:5]
```

```{r}
sel <- zweitwohnung_kanton$KANTONSNAME[1]
```

```{r}
#| eval: true
#| 
sel <- ""
MI <- ""
```


Zur Überprüfung unserer Operation: Mit `w[1,]` bekommt  ihr ein Vektor, wo bei allen Kantone, die den ersten kanton (`r sel`) berühren `TRUE` steht und bei allen anderen `FALSE`. Nun können wir überprüfen, ob die räumliche Operation funktioniert hat. Könnt ihr die nachfolgende Visualisierung rekonstruieren?

```{r}
beruehrt_1 <- w[1, ]

ggplot(zweitwohnung_kanton[beruehrt_1, ]) +
  geom_sf(aes(fill = KANTONSNAME)) +
  labs(title = "Welche Kanton berühren den Kanton Zürich (st_touches)")
```


### Abweichung vom Mittelwert

$$I = \frac{n}{\sum_{i=1}^n (y_i - \bar{y})^2} \times \frac{\sum_{i=1}^n \sum_{j=1}^n w_{ij}{\color{red}(y_i - \bar{y})(y_j - \bar{y})}}{\sum_{i=1}^n \sum_{j=1}^n w_{ij}}$$

Die Abweichung vom Mittelwert haben wir ja bereits gerechnet und in der Variabel `dy` abgespeichert. Nun gilt es paarweise das Produkt der Abweichungen vom Mittelwert (die Covarianz) zu berechnen $(y_i - \bar{y})(y_j - \bar{y})$.  Dazu müssen wir *das Produkt aller Wertekombinationen* berechnen. Dies erreichen wir mit der Funktion `tcrossprod()`

```{r}
#| echo: true

# berechnet das Proukt aller Wertekombinationen
pm <- tcrossprod(dy)

# die ersten für Reihen und Spalten des Resultas
pm[1:5,1:5]
```


<!--
Nun multiplizieren wir die Covarianzen mit den Gewichten $w$ (Schalter), damit wir nur noch die Werte von den Kantonen haben, die auch effektiv benachbart sind (und eliminieren nicht-benachbarte Werte). Beachtet dass wir hier nun eine Matrix mit einer Matrix multiplizieren.

```{r}
#| echo: true
pmw <- pm * w
w[1:5,1:5]
pmw[1:5,1:5]
```

Den Zähler des ersten Bruches können wir nun fertig berechnen, indem wir die Summe aller gewichten (sprich eingeschalteten) Werten bilden:

```{r}
#| echo: true
spmw <- sum(pmw, na.rm = TRUE)
spmw
```


#### Nenner (Bruch 2)

Für den Nenner des zweiten Teils der Formal (des zweiten Bruchs) müssen wir nun nur noch alle Gewichte summieren. Diese Summer entspricht der Anzahl effektiv benachbarter Kantone und kann Anzahl der `TRUE`-Werte in $w$ bestimmt werden. 

```{r}
#| echo: true
smw <- sum(w, na.rm = TRUE)
```

#### Auflösung (Bruch 2)

So können wir den zweiten Bruch auflösen und berechnen:

```{r}
#| echo: true
sw  <- spmw / smw
```

### Auflösung der Formel

Der allerletzte Schritt besteht darin, die Werte aus den beiden Brüche miteinander zu multiplizieren.

```{r}
#| echo: true
MI <- vr * sw
MI
```

-->
Der Global Morans $I$ für die Abstimmungsdaten beträgt auf Kantonsebene also `r MI`. Wie interpretiert ihr dieses Resultate? Was erwartet ihr für eine Resultat auf Gemeinde- oder Bezirksebene?

## Aufgabe 2: Morans I für Gemeinde oder Bezirke berechnen

Nun könnt ihr Morans $I$ auf der Ebene der Gemeine oder Bezirke und untersuchen, ob und wie sich Morans $I$ verändert. Wenn ihr einen wenig leistungsfähigen Rechner habt, berechnet verwendet besser die Ebene "Berzirke". Importiert dazu den Layer `berirk` oder `gemeinde` aus dem Datensatz `zweitwohnungsinitiative.gpkg`. Visualisiert in einem ersten Schritt die Abstimmungsresultate. Tipp: wir verwenden das Package `cowplot` um zwei `ggplots` nebeneinander darzustellen.

Nach der Brechnung von Morans $I$ könnt ihr die Werte auf der Ebene Gemeinde (bzw. Bezirke) und Kantone vergleichen. Formuliert zuerste eine Erwartungshaltung: ist Morans $I$ auf der Ebene Gemeinde (bzw. Bezirke) tiefer oder Höher als auf der Ebene Kantone?

:::{.callout-note}
## Für Fortgeschrittene 

Erstellt aus dem erarbeiten Workflow eine *function* um Morans I auf der Basis von einem `sf` Objekt sowie einer Spalte dessen zu berechnen. 
:::

```{r}
#| echo: false
#| layout-ncol: 2
#| column: page

zweitwohnung_gemeinde <- read_sf("datasets/rauman/zweitwohnungsinitiative.gpkg", "gemeinde")

p2 <- ggplot(zweitwohnung_gemeinde) +
  geom_sf(aes(fill = ja_in_percent), colour = "white",lwd = 0.2) +
  scale_fill_gradientn("Ja Anteil",colours = RColorBrewer::brewer.pal(11, "RdYlGn"), limits = c(0,1)) +
  theme(legend.position = "none") +
  labs(title = "Gemeinden: Global Morans I: ?")

p1 <- p + labs(title = paste("Kantone: Global Morans I:",round(MI,2))) + theme(legend.position = "none")

p1

p2
```

```{r}
#| echo: false
#| fig-height: 1
#| out-width: 100%
#| column: page

library(cowplot)

(p  + labs(fill = "Ja (in %)")) |>
get_legend() |>
ggdraw()

```

```{r}
morans_i <- function(sf_object,col) {
  library(sf)
  n <- nrow(sf_object)
  y <- unlist(st_drop_geometry(sf_object)[,col],use.names = FALSE)
  ybar <- mean(y, na.rm = TRUE)
  dy <- y - ybar
  dy_sum <- sum(dy^2, na.rm = TRUE)
  vr <- n/dy_sum
  w <- st_touches(sf_object,sparse = FALSE)
  pm <- tcrossprod(dy)
  pmw <- pm * w
  spmw <- sum(pmw, na.rm = TRUE)
  smw <- sum(w, na.rm = TRUE)
  sw  <- spmw / smw
  MI <- vr * sw
  MI
}
```

```{r}
#| eval: false
MI_gemeinde <-  morans_i(zweitwohnung_gemeinde,"ja_in_percent")
morans_i(zweitwohnung_kanton,"ja_in_percent")
```