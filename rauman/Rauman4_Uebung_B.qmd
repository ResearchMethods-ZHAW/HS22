---
date: 2022-12-06
lesson: RaumAn4
thema: Einführung Rasterdaten
index: 2
---

# Rauman 4: Übung B {#sec-raster-intro}

Einer der wichtigsten Aspekte der bevorstehenden Übung (Multi-Criteria Evaluation (MCE)) ist die Verwendung und Bearbeitung von **Rasterdatensätzen**. In "R" werden hauptsächlich zwei Pakete zur Bearbeitung von Rasterdaten verwendet: `terra` und das Paket `raster`. Das letztere wird immer noch stark genutzt, wird aber unweigerlich durch das erstere ersetzt.

Im dieser Übung werden wir `terra` verwenden, um zu zeigen, wie wir einen Rasterdatensatz importieren können. Unter dem untenstehenden Link können Sie eine tif-Datei herunterladen, die das "Digitale Höhenmodell" (DHM)* des Kantons Schwyz in der Schweiz darstellt. Laden Sie den Datensatz herunter und führen Sie den angegebenen Code aus.

Datensatz: [dhm25m.tif](https://moodle.zhaw.ch/mod/resource/view.php?id=602285)

```{r}
library(terra)
```

Importieren Sie Ihr Raster mit der Funktion `rast`

```{r}
dhm_schwyz <- rast("datasets/rauman/dhm250m.tif")
```

Sie erhalten einige wichtige Metadaten über den Rasterdatensatz, wenn Sie den Variablennamen in die Konsole eingeben.  

```{r}
dhm_schwyz 
```

Um einen schnellen Überblick eines Rasterdatensatz zu erhalten, können wir einfach die `plot()` Funktion verwenden.

```{r}
plot(dhm_schwyz)
```

Leider ist das Verwenden von `Rastern` in ggplot nicht sehr einfach. Da `ggplot` ein universelles Plot-Framework ist, stossen wir schnell an die Grenzen des Möglichen, wenn wir etwas so Spezielles wie Karten erstellen. Aus diesem Grund werden wir ein neues Plot-Framework einführen, das auf Karten spezialisiert ist und in einem sehr ähnlichen Design wie ggplot gebaut wurde: `tmap`. Installieren und laden Sie dieses Paket jetzt.

```{r}
library(tmap)
```

Genau wie `ggplot` basiert `tmap` auf der Idee von "Ebenen", die durch ein `+` verbunden sind. Jede Ebene hat zwei Komponenten:

- eine Datensatzkomponente, die immer `tm_shape(dataset)` ist (ersetzen Sie `dataset` durch Ihre Variable)
- eine Geometriekomponente, die beschreibt, wie das vorangegangene `tm_shape()` visualisiert werden soll. Dies kann `tm_dots()` für Punkte, `tm_polygons()` für Polygone, `tm_lines()` für Linien usw. sein. Für Einzelbandraster (was bei `dhm_schwyz` der Fall ist) ist es `tm_raster()`

```{r}

tm_shape(dhm_schwyz) + 
  tm_raster() 
```

Beachten Sie, dass `tm_shape()` und `tm_raster()` (in diesem Fall) zusammengehören. Das eine kann nicht ohne das andere leben.

Wenn Sie die Hilfe von `?tm_raster` konsultieren, werden Sie eine Vielzahl von Optionen sehen, mit denen Sie die Visualisierung Ihrer Daten verändern können. Zum Beispiel ist der Standardstil von `tm_raster()` die Erstellung von "Bins" mit einer diskreten Farbskala. Wir können dies mit `style = "cont"` ausser Kraft setzen.

```{r}

tm_shape(dhm_schwyz) + 
  tm_raster(style = "cont") 
```

Das sieht schon ziemlich toll aus, aber vielleicht wollen wir die Standard-Farbpalette ändern. Glücklicherweise ist das in `tmap` viel einfacher als in `ggplot2`. Um sich die verfügbaren Paletten anzusehen, geben Sie `tmaptools::palette_explorer()` oder `RColorBrewer::display.brewer.all()` in der Konsole ein (für Ersteres müssen Sie möglicherweise zusätzliche Pakete installieren, z.B. `shinyjs`).

```{r}

tm_shape(dhm_schwyz) + 
  tm_raster(style = "cont", palette = "Spectral") 
```

Sie können Layout-Anpassungen mit `tm_layout()` vornehmen, prüfen Sie `?tm_layout`, um alle verfügbaren Optionen zu sehen.

::: {.column-body}
```{r}

tm_shape(dhm_schwyz) + 
  tm_raster(style = "cont", palette = "Spectral", legend.is.portrait = FALSE, title = "") +
  tm_layout(legend.outside = TRUE, legend.outside.position = "bottom",frame = FALSE)
```
:::



## Aufgabe 1 {#sec-raster-slope}

Mit `terra` können wir eine Vielzahl von Rasteroperationen über unser Höhenmodell laufen lassen. Eine klassische Rasteroperation ist zum Beispiel das Berechnenen der Hangneigung oder dessen Orientierung. Nutzen Sie die Funktion `terrain()` aus `terra` um die Hangneigung und Orientierung zu berechnen. Visualisieren Sie die Resultate.

```{r}
#| echo: false

terrain(dhm_schwyz, "slope") |>
 plot()


terrain(dhm_schwyz, "aspect") |>
  plot()

```


## Aufgabe 2

Mit Hangneigung und -ausrichtung können wir einen *Hillshading*-Effekt berechnen. Hillshading bedeutet, dass der Schattenwurf des Oberflächenmodells bei gegebenen Einfallswinkel der Sonne (Höhe und Azimut) berechnet wird. Der typische Einfallswinkel liegt bei 45° über dem Horizont und von Nordwesten bei 315°.

Um einen Hillshading Effekt zu erzeugen, berechne zuerst `slope` und `aspect` von `dhm_schwyz` analog der letzten Aufgabe, achte aber darauf das die Einheit `radians` entspricht. Nutze diese beiden Objekte um den Hillshade zu berechnen. Visualisiere den Output anschliessend mit `plot` oder `tmap`.

```{r}
#| echo: false
#| fig-cap: Für diese Visualisierung verwende ich `tmap` und als colour palette *cividis*
dhm_slope <- terrain(dhm_schwyz, "slope", unit = "radians")
dhm_aspect <- terrain(dhm_schwyz, "aspect", unit = "radians")

dhm_hillshade <- shade(dhm_slope, dhm_aspect, 45, 315)

tm_shape(dhm_hillshade) + 
  tm_raster(style = "cont", palette = "cividis", legend.show = FALSE) +
  tm_layout(frame = FALSE)

```

