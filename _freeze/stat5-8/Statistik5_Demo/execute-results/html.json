{
  "hash": "b5fa677817a82b30a753d28391a60b24",
  "result": {
    "markdown": "# Stat5: Demo\n\n\n\n\n::: {.cell}\n\n:::\n\n\n\n\n\n# Von linearen Modellen zu GLMMs\n- [Demoscript als Download](Statistik5_Demo.R)\n- Datensatz [spf.csv](https://media.githubusercontent.com/media/ResearchMethods-ZHAW/datasets/main/statistik/spf.csv)\n- Datensatz [DeerEcervi.txt](https://media.githubusercontent.com/media/ResearchMethods-ZHAW/datasets/main/statistik/DeerEcervi.txt)\n\n## Split-plot ANOVA\nBased on Logan (2010), Chapter 14\n\n\n::: {.cell}\n\n```{.r .cell-code}\nspf <- read.delim(here(\"data\",\"spf.csv\"), sep = \";\") \nspf.aov <- aov(Reaktion~Signal * Messung + Error(VP), data = spf)\nsummary(spf.aov)\n\ninteraction.plot(spf$Messung, spf$Signal, spf$Reaktion)\n\n# nun als LMM\nif(!require(nlme)){install.packages(\"nlme\")}\nlibrary(nlme)\n\n# mit random intercept (VP) und random slope (Messung)\nspf.lme.1 <- lme(Reaktion~Signal * Messung, random = ~Messung | VP, data = spf)\n# nur random intercept\nspf.lme.2 <- lme(Reaktion~Signal * Messung, random = ~1 | VP, data = spf)\n\nanova(spf.lme.1)\nanova(spf.lme.2)\n\nsummary(spf.lme.1)\nsummary(spf.lme.2)\n```\n:::\n\n\n## GLMM\nBased on Zuur et al. (2009), chapter 13\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDeerEcervi <- read.delim(here(\"data\",\"DeerEcervi.txt\"), sep = \"\", stringsAsFactors = T)\n\n\n# Anzahl Larven hier in Presence/Absence übersetzt\nDeerEcervi$Ecervi.01 <- DeerEcervi$Ecervi\nDeerEcervi$Ecervi.01[DeerEcervi$Ecervi>0] <- 1\n\n#Numerische Geschlechtscodierung als Factor\nDeerEcervi$fSex <- as.factor(DeerEcervi$Sex)\n```\n:::\n\n\nHirschlänge hier standardisiert, sonst würde der Achsenabschnitt im Modell für einen Hirsch der Länge 0 modelliert, was schlecht interpretierbar ist, jetzt ist der Achsenabschnitt für einen durschnittlich langen Hirsch\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDeerEcervi$CLength <- DeerEcervi$Length - mean(DeerEcervi$Length)\n\n# Zunächst als GLM\n# Interaktionen mit fFarm nicht berücksichtigt, da zu viele Freiheitsgrade verbraucht würden\nDE.glm <- glm(Ecervi.01 ~ CLength * fSex + Farm, family = binomial, data = DeerEcervi)\n\ndrop1(DE.glm, test = \"Chi\")\nsummary(DE.glm)\nanova(DE.glm)\n\n\n# Response curves für die einzelnen Farmen (Weibliche Tiere: fSex = \"1\" )\nplot(DeerEcervi$CLength, DeerEcervi$Ecervi.01,\n     xlab = \"Length\", ylab = \"Probability of \\\n     presence of E. cervi L1\")\n\nI <- order(DeerEcervi$CLength)\nAllFarms <- unique(DeerEcervi$Farm)\nfor (j in AllFarms){\n  mydata <- data.frame(CLength=DeerEcervi$CLength, fSex = \"1\",\n                       Farm = j)\n  n <- dim(mydata)[1]\n  if (n>10){\n    P.DE2 <- predict(DE.glm, mydata, type = \"response\")\n    lines(mydata$CLength[I], P.DE2[I])\n  }}\n```\n:::\n\n\n## GLMM\n\n\n::: {.cell}\n\n```{.r .cell-code}\nif(!require(MASS)){install.packages(\"MASS\")}\nlibrary(MASS)\nDE.PQL <- glmmPQL(Ecervi.01 ~ CLength * fSex,\n                random = ~ 1 | Farm, family = binomial, data = DeerEcervi)\nsummary(DE.PQL)\n\n\ng <- 0.8883697 + 0.0378608 * DeerEcervi$CLength\np.averageFarm1 <- exp(g)/(1 + exp(g))\nI <- order(DeerEcervi$CLength)  #Avoid spaghetti plot\nplot(DeerEcervi$CLength, DeerEcervi$Ecervi.01, xlab=\"Length\",\n     ylab = \"Probability of presence of E. cervi L1\")\nlines(DeerEcervi$CLength[I], p.averageFarm1[I],lwd = 3)\np.Upp <- exp(g + 1.96 * 1.462108)/(1 + exp(g + 1.96 * 1.462108))\np.Low <- exp(g - 1.96 * 1.462108)/(1 + exp(g - 1.96 * 1.462108))\nlines(DeerEcervi$CLength[I], p.Upp[I])\nlines(DeerEcervi$CLength[I], p.Low[I])\n\n\nif(!require(lme4)){install.packages(\"lme4\")}\nlibrary(lme4)\nDE.lme4 <- glmer(Ecervi.01 ~ CLength * fSex + (1|Farm), \n                 family = binomial, data = DeerEcervi)\nsummary(DE.lme4)\n\nif(!require(glmmML)){install.packages(\"glmmML\")}\nlibrary(glmmML)\nDE.glmmML <- glmmML(Ecervi.01 ~ CLength * fSex,\n                  cluster = Farm, family = binomial, data = DeerEcervi)\nsummary(DE.glmmML)\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}