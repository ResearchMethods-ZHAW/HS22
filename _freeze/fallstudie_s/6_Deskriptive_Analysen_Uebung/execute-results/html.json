{
  "hash": "e072ec5efdcf45b3fd9a361c64978a96",
  "result": {
    "markdown": "# 6. Übung\n\n\n\n\n::: {.cell}\n\n:::\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Benoetigte Bibliotheken ####\nlibrary(tidyverse) # Data wrangling und piping\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n── Attaching packages ─────────────────────────────────────── tidyverse 1.3.2 ──\n✔ ggplot2 3.3.6     ✔ purrr   0.3.4\n✔ tibble  3.1.8     ✔ dplyr   1.0.9\n✔ tidyr   1.2.0     ✔ stringr 1.4.1\n✔ readr   2.1.2     ✔ forcats 0.5.2\n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\n```\n:::\n\n```{.r .cell-code}\nlibrary(lubridate) # Arbeiten mit Datumsformaten\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'lubridate'\n\nThe following objects are masked from 'package:base':\n\n    date, intersect, setdiff, union\n```\n:::\n\n```{.r .cell-code}\nlibrary(data.table)# schnelles Dateneinlesen\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'data.table'\n\nThe following objects are masked from 'package:lubridate':\n\n    hour, isoweek, mday, minute, month, quarter, second, wday, week,\n    yday, year\n\nThe following objects are masked from 'package:dplyr':\n\n    between, first, last\n\nThe following object is masked from 'package:purrr':\n\n    transpose\n```\n:::\n\n```{.r .cell-code}\nlibrary(ggpubr)    # to arrange multiple plots in one graph\nlibrary(PerformanceAnalytics) # Plotte Korrelationsmatrix\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: xts\nLoading required package: zoo\n\nAttaching package: 'zoo'\n\nThe following objects are masked from 'package:base':\n\n    as.Date, as.Date.numeric\n\n\nAttaching package: 'xts'\n\nThe following objects are masked from 'package:data.table':\n\n    first, last\n\nThe following objects are masked from 'package:dplyr':\n\n    first, last\n\n\nAttaching package: 'PerformanceAnalytics'\n\nThe following object is masked from 'package:graphics':\n\n    legend\n```\n:::\n\n```{.r .cell-code}\nlibrary(MuMIn)     # Multi-Model Inference\nlibrary(AICcmodavg)# Modellaverageing\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'AICcmodavg'\n\nThe following objects are masked from 'package:MuMIn':\n\n    AICc, DIC, importance\n```\n:::\n\n```{.r .cell-code}\nlibrary(fitdistrplus)# Prueft die Verteilung in Daten\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: MASS\n\nAttaching package: 'MASS'\n\nThe following object is masked from 'package:dplyr':\n\n    select\n\nLoading required package: survival\n```\n:::\n\n```{.r .cell-code}\nlibrary(lme4)      # Multivariate Modelle\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: Matrix\n\nAttaching package: 'Matrix'\n\nThe following objects are masked from 'package:tidyr':\n\n    expand, pack, unpack\n\n\nAttaching package: 'lme4'\n\nThe following object is masked from 'package:AICcmodavg':\n\n    checkConv\n```\n:::\n\n```{.r .cell-code}\nlibrary(blmeco)    # Bayesian data analysis using linear models\nlibrary(sjPlot)    # Plotten von Modellergebnissen (tab_model)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n#refugeeswelcome\n```\n:::\n\n```{.r .cell-code}\nlibrary(lattice)   # einfaches plotten von Zusammenhängen zwischen Variablen\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Start und Ende ####\n# Untersuchungszeitraum, ich waehle hier das Jahr 2019 bis und mit Sommer 2021\ndepo_start <- as.Date(\"2019-01-01\")\ndepo_end <- as.Date(\"2021-7-27\")\n\n# Start und Ende Lockdown\n# definieren, wichtig fuer die spaeteren Auswertungen\nlock_1_start_2020 <- as.Date(\"2020-03-16\")\nlock_1_end_2020 <- as.Date(\"2020-05-11\")\n\nlock_2_start_2021 <- as.Date(\"2020-12-22\")\nlock_2_end_2021 <- as.Date(\"2021-03-01\")\n\n# Ebenfalls muessen die erste und letzte Kalenderwoche der Untersuchungsfrist definiert werden\n# Diese werden bei Wochenweisen Analysen ebenfalls ausgeklammert da sie i.d.R. unvollstaendig sind\nKW_start <- week(depo_start)\nKW_end <- week(depo_end)\n\n# Erster und letzter Tag der Ferien\n# je nach Untersuchungsdauer muessen hier weitere oder andere Ferienzeiten ergaenzt werden\n# (https://www.schulferien.org/schweiz/ferien/2020/)\nFruehlingsferien_2019_start <- as.Date(\"2019-04-13\")\nFruehlingsferien_2019_ende <- as.Date(\"2019-04-28\")\nSommerferien_2019_start <- as.Date(\"2019-07-6\")\nSommerferien_2019_ende <- as.Date(\"2019-08-18\")\nHerbstferien_2019_start <- as.Date(\"2019-10-05\")\nHerbstferien_2019_ende <- as.Date(\"2019-10-20\")\nWinterferien_2019_start <- as.Date(\"2019-12-21\")\nWinterferien_2019_ende <- as.Date(\"2020-01-02\")\n\nFruehlingsferien_2020_start <- as.Date(\"2020-04-11\")\nFruehlingsferien_2020_ende <- as.Date(\"2020-04-26\")\nSommerferien_2020_start <- as.Date(\"2020-07-11\")\nSommerferien_2020_ende <- as.Date(\"2020-08-16\")\nHerbstferien_2020_start <- as.Date(\"2020-10-03\")\nHerbstferien_2020_ende <- as.Date(\"2020-10-18\")\nWinterferien_2020_start <- as.Date(\"2020-12-19\")\nWinterferien_2020_ende <- as.Date(\"2021-01-03\")\n\nFruehlingsferien_2021_start <- as.Date(\"2021-04-24\")\nFruehlingsferien_2021_ende <- as.Date(\"2021-05-09\")\nSommerferien_2021_start <- as.Date(\"2021-07-17\")\n\n#.################################################################################################\n# 1. DATENIMPORT #####\n#.################################################################################################\n\n# Beim Daten einlesen koennen sogleich die Datentypen und erste Bereinigungen vorgenommen werden\n\n# 1.1 Zaehldaten ####\n# Die Zaehldaten des Wildnispark wurden vorgaengig bereinigt. z.B. wurden Stundenwerte \n# entfernt, an denen am Zaehler Wartungsarbeiten stattgefunden haben.\n\n# lese die Daten mithilfe der Bibliothek data.table ein (alternative zu read_csv und dergleichen). \n# Je nach Bedarf muss der Speicherort sowie der Dateiname angepasst werden\ndepo <- fread(here(\"data\",\"211_sihlwaldstrasse_2017_2021.csv\"))\n\n# Hinweis zu den Daten:\n# In hourly analysis format, the data at 11:00 am corresponds to the counts saved between \n# 11:00 am and 12:00 am.\n\n# Anpassen der Datentypen und erstes Sichten\nstr(depo)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nClasses 'data.table' and 'data.frame':\t40152 obs. of  5 variables:\n $ DatumUhrzeit: chr  \"01.01.2017 00:00\" \"01.01.2017 01:00\" \"01.01.2017 02:00\" \"01.01.2017 03:00\" ...\n $ Fuss_IN     : int  0 0 0 0 0 0 0 0 0 0 ...\n $ Fuss_OUT    : int  0 0 0 0 0 0 0 0 0 0 ...\n $ Velo_IN     : int  0 0 0 0 0 0 0 0 0 0 ...\n $ Velo_OUT    : int  0 0 0 0 0 0 0 0 0 0 ...\n - attr(*, \".internal.selfref\")=<externalptr> \n```\n:::\n\n```{.r .cell-code}\ndepo <- depo %>%\n  mutate(Datum_Uhrzeit = as.character(DatumUhrzeit)) %>%\n  separate(Datum_Uhrzeit, into = c(\"Datum\", \"Zeit\"), sep = \" \")%>%\n  mutate(Datum = as.Date(Datum, format = \"%d.%m.%Y\")) %>% \n  # Schneide das df auf den gewuenschten Zeitraum zu\n  filter(Datum >= depo_start, Datum <=  depo_end) # das Komma hat die gleiche Funktion wie ein &\n\n# In dieser Auswertung werden nur Velos betrachtet!\ndepo <- depo[,-c(1,4,5), drop=FALSE] # mit diesem Befehl lassen wir Spalten \"fallen\", \n                                     # aendern aber nichts an der Form des data.frames\n\n# Berechnen des Totals, da dieses in den Daten nicht vorhanden ist\ndepo <- depo%>%\n  mutate(Total = Fuss_IN + Fuss_OUT)\n\n# Entferne die NA's in dem df.\ndepo <- na.omit(depo)\n\n# 1.2 Meteodaten ####\n# Einlesen\nmeteo <- fread(here(\"data\",\"order_97149_data.txt\"))\n\n# Datentypen setzen\n# Das Datum wird als Integer erkannt. Zuerst muss es in Text umgewaldelt werden aus dem dann\n# das eigentliche Datum herausgelesen werden kann\nmeteo <- transform(meteo, time = as.Date(as.character(time), \"%Y%m%d\"))\n\n# Die eigentlichen Messwerte sind alle nummerisch\nmeteo <- meteo%>%\n  mutate(tre200jx = as.numeric(tre200jx))%>%\n  mutate(rre150j0 = as.numeric(rre150j0))%>%\n  mutate(sremaxdv = as.numeric(sremaxdv)) %>% \n  filter(time >= depo_start, time <=  depo_end) # schneide dann auf Untersuchungsdauer\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in mask$eval_all_mutate(quo): NAs introduced by coercion\n\nWarning in mask$eval_all_mutate(quo): NAs introduced by coercion\n```\n:::\n\n```{.r .cell-code}\n# Was ist eigentlich Niederschlag:\n# https://www.meteoschweiz.admin.ch/home/wetter/wetterbegriffe/niederschlag.html\n\n# Filtere Werte mit NA\nmeteo <- meteo %>%\n  filter(!is.na(stn)) %>%\n  filter(!is.na(time))%>%\n  filter(!is.na(tre200jx))%>%\n  filter(!is.na(rre150j0))%>%\n  filter(!is.na(sremaxdv))\n# Pruefe ob alles funktioniert hat\nstr(meteo)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nClasses 'data.table' and 'data.frame':\t939 obs. of  5 variables:\n $ stn     : chr  \"WAE\" \"WAE\" \"WAE\" \"WAE\" ...\n $ time    : Date, format: \"2019-01-01\" \"2019-01-02\" ...\n $ tre200jx: num  4.9 2.7 0 1.5 2.3 2.2 2.8 4.1 2 -0.5 ...\n $ rre150j0: num  0 0 0 0 8.4 3.9 0 8.1 1.8 4.6 ...\n $ sremaxdv: num  0 0 58 73 0 0 0 0 0 0 ...\n - attr(*, \".internal.selfref\")=<externalptr> \n```\n:::\n\n```{.r .cell-code}\nsum(is.na(meteo)) # zeigt die Anzahl NA's im data.frame an\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0\n```\n:::\n\n```{.r .cell-code}\n#.################################################################################################\n# 2. VORBEREITUNG DER DATEN #####\n#.################################################################################################\n\n# 2.1 Convinience Variablen ####\n# fuege dem Dataframe (df) die Wochentage hinzu\ndepo <- depo %>% \n  mutate(Wochentag = weekdays(Datum)) %>% \n  # R sortiert die Levels aplhabetisch. Da das in unserem Fall aber sehr unpraktisch ist,\n  # muessen die Levels manuell manuell bestimmt werden\n  mutate(Wochentag = base::factor(Wochentag, \n                            levels = c(\"Montag\", \"Dienstag\", \"Mittwoch\", \n                                       \"Donnerstag\", \"Freitag\", \"Samstag\", \"Sonntag\"))) %>% \n  # Werktag oder Wochenende hinzufuegen\n  mutate(Wochenende = if_else(Wochentag == \"Montag\" | Wochentag == \"Dienstag\" | \n                           Wochentag == \"Mittwoch\" | Wochentag == \"Donnerstag\" | \n                           Wochentag == \"Freitag\", \"Werktag\", \"Wochenende\"))%>%\n  #Kalenderwoche hinzufuegen\n  mutate(KW= week(Datum))%>%\n  # monat und Jahr\n  mutate(Monat = month(Datum)) %>% \n  mutate(Jahr = year(Datum))\n\n#Lockdown \n# Hinweis: ich mache das nachgelagert, da ich die Erfahrung hatte, dass zu viele \n# Operationen in einem Schritt auch schon mal durcheinander erzeugen koennen.\n# Hinweis II: Wir packen alle Phasen (normal, die beiden Lockdowns und Covid aber ohne Lockdown)\n# in eine Spalte --> long ist schoener als wide\ndepo <- depo %>%\nmutate(Phase = if_else(Datum >= lock_1_start_2020 & Datum <= lock_1_end_2020,\n                          \"Lockdown_1\",\n                       if_else(Datum >= lock_2_start_2021 & Datum <= lock_2_end_2021,\n                               \"Lockdown_2\",\n                               if_else(Datum < lock_1_start_2020,\n                                  \"Normal\", \"Covid\"))))\n\n# hat das gepklappt?!\nunique(depo$Phase)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Normal\"     \"Lockdown_1\" \"Covid\"      \"Lockdown_2\"\n```\n:::\n\n```{.r .cell-code}\n# aendere die Datentypen\ndepo <- depo %>% \n  mutate(Wochenende = as.factor(Wochenende)) %>% \n  mutate(KW = factor(KW)) %>% \n  # mit factor() koennen die levels direkt einfach selbst definiert werden.\n  # wichtig: speizfizieren, dass aus R base, ansonsten kommt es zu einem \n  # mix-up mit anderen packages\n  mutate(Phase = base::factor(Phase, levels = c(\"Normal\", \"Lockdown_1\", \"Lockdown_2\", \"Covid\")))\n\nstr(depo)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nClasses 'data.table' and 'data.frame':\t22088 obs. of  11 variables:\n $ Fuss_IN   : int  0 0 0 0 0 0 0 0 0 0 ...\n $ Fuss_OUT  : int  0 0 0 0 0 0 0 0 0 0 ...\n $ Datum     : Date, format: \"2019-01-01\" \"2019-01-01\" ...\n $ Zeit      : chr  \"00:00\" \"01:00\" \"02:00\" \"03:00\" ...\n $ Total     : int  0 0 0 0 0 0 0 0 0 0 ...\n $ Wochentag : Factor w/ 7 levels \"Montag\",\"Dienstag\",..: NA NA NA NA NA NA NA NA NA NA ...\n $ Wochenende: Factor w/ 0 levels: NA NA NA NA NA NA NA NA NA NA ...\n $ KW        : Factor w/ 53 levels \"1\",\"2\",\"3\",\"4\",..: 1 1 1 1 1 1 1 1 1 1 ...\n $ Monat     : int  1 1 1 1 1 1 1 1 1 1 ...\n $ Jahr      : int  2019 2019 2019 2019 2019 2019 2019 2019 2019 2019 ...\n $ Phase     : Factor w/ 4 levels \"Normal\",\"Lockdown_1\",..: 1 1 1 1 1 1 1 1 1 1 ...\n - attr(*, \".internal.selfref\")=<externalptr> \n```\n:::\n\n```{.r .cell-code}\n# Fuer einige Auswertungen muss auf die Stunden als nummerischer Wert zurueckgegriffen werden\ndepo$Stunde <- as.numeric(format(as.POSIXct(depo$Zeit,format=\"%H:%M\"),\"%H\"))\n\n# Die Daten wurden kalibriert. Wir runden sie fuer unserer Analysen auf Ganzzahlen\ndepo$Total <- round(depo$Total, digits = 0)\ndepo$Fuss_IN <- round(depo$Fuss_IN, digits = 0)\ndepo$Fuss_OUT <- round(depo$Fuss_OUT, digits = 0)\n\n# 2.3 Aggregierung der Stundendaten zu ganzen Tagen ####\n# Zur Berechnung von Kennwerten ist es hilfreich, wenn neben den Stundendaten auch auf Ganztagesdaten\n# zurueckgegriffen werden kann\n# hier werden also pro Nutzergruppe und Richtung die Stundenwerte pro Tag aufsummiert\ndepo_d <- depo %>% \n  group_by(Datum, Wochentag, Wochenende, KW, Monat, Jahr, Phase) %>% \n  summarise(Total = sum(Fuss_IN + Fuss_OUT), \n            Fuss_IN = sum(Fuss_IN),\n            Fuss_OUT = sum(Fuss_OUT)) \n```\n\n::: {.cell-output .cell-output-stderr}\n```\n`summarise()` has grouped output by 'Datum', 'Wochentag', 'Wochenende', 'KW',\n'Monat', 'Jahr'. You can override using the `.groups` argument.\n```\n:::\n\n```{.r .cell-code}\n# Wenn man die Convinience Variablen als grouping variable einspeisst, dann werden sie in \n# das neue df uebernommen und muessen nicht nochmals hinzugefuegt werden\n\n# pruefe das df\nhead(depo_d)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 10\n# Groups:   Datum, Wochentag, Wochenende, KW, Monat, Jahr [6]\n  Datum      Wochentag Wochenende KW    Monat  Jahr Phase  Total Fuss_IN Fuss_…¹\n  <date>     <fct>     <fct>      <fct> <int> <int> <fct>  <dbl>   <dbl>   <dbl>\n1 2019-01-01 <NA>      <NA>       1         1  2019 Normal    21      11      10\n2 2019-01-02 <NA>      <NA>       1         1  2019 Normal    36      20      16\n3 2019-01-03 <NA>      <NA>       1         1  2019 Normal    26      14      12\n4 2019-01-04 <NA>      <NA>       1         1  2019 Normal    10       7       3\n5 2019-01-05 <NA>      <NA>       1         1  2019 Normal    12       8       4\n6 2019-01-06 <NA>      <NA>       1         1  2019 Normal    25      15      10\n# … with abbreviated variable name ¹​Fuss_OUT\n```\n:::\n\n```{.r .cell-code}\n# Gruppiere die Werte nach Monat\ndepo_m <- depo %>% \n  group_by(Jahr, Monat) %>% \n  summarise(Total = sum(Total)) \n```\n\n::: {.cell-output .cell-output-stderr}\n```\n`summarise()` has grouped output by 'Jahr'. You can override using the\n`.groups` argument.\n```\n:::\n\n```{.r .cell-code}\n# sortiere das df aufsteigend (nur das es sicher stimmt)\ndepo_m <- as.data.frame(depo_m)\ndepo_m[\n  with(depo_m, order(Jahr, Monat)),]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Jahr Monat Total\n1  2019     1   437\n2  2019     2   479\n3  2019     3   832\n4  2019     4  1050\n5  2019     5  1385\n6  2019     6  1658\n7  2019     7  1162\n8  2019     8  1115\n9  2019     9   865\n10 2019    10   790\n11 2019    11   635\n12 2019    12   460\n13 2020     1   633\n14 2020     2   623\n15 2020     3  1473\n16 2020     4  3038\n17 2020     5  2905\n18 2020     6  1333\n19 2020     7  1185\n20 2020     8  1335\n21 2020     9  1197\n22 2020    10  1650\n23 2020    11  1353\n24 2020    12   935\n25 2021     1   862\n26 2021     2   992\n27 2021     3  1002\n28 2021     4  1888\n29 2021     5  1962\n30 2021     6  1304\n31 2021     7   831\n```\n:::\n\n```{.r .cell-code}\n# mache dann aus Jahr und Monat faktoren\ndepo_m <- depo_m %>% \n  mutate(Jahr = as.factor(Jahr)) %>% \n  mutate(Monat = as.factor(Monat)) %>% \n  mutate(Ym = paste(Jahr, Monat)) %>% # und mache eine neue Spalte, in der Jahr und\n  mutate(Ym= factor(Ym, levels=unique(Ym))) # Monat in zusammen sind\n\n\n#.################################################################################################\n# 3. DESKRIPTIVE ANALYSE UND VISUALISIERUNG #####\n#.################################################################################################\n\n# 3.1 Verlauf der Besuchszahlen / m ####\n# Monatliche Summen am Standort\n\n# wann beginnt die Datenreihe schon wieder?\nfirst(depo_m$Ym)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2019 1\n31 Levels: 2019 1 2019 2 2019 3 2019 4 2019 5 2019 6 2019 7 2019 8 ... 2021 7\n```\n:::\n\n```{.r .cell-code}\n# und wann ist die fertig?\nlast(depo_m$Ym)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2021 7\n31 Levels: 2019 1 2019 2 2019 3 2019 4 2019 5 2019 6 2019 7 2019 8 ... 2021 7\n```\n:::\n\n```{.r .cell-code}\n# Plotte\nggplot(depo_m, mapping = aes(Ym, Total, group = 1))+ # group 1 braucht R, dass aus den Einzelpunkten ein Zusammenhang hergestellt wird\n  #zeichne Lockdown 1\n  geom_rect(mapping = aes(xmin=\"2020 3\", xmax=\"2020 5\",\n                          ymin =0, ymax=max(Total+(Total/100*10))),\n            fill = \"lightskyblue\", alpha = 0.4, colour = NA)+\n  #zeichne Lockdown 2\n    geom_rect(mapping = aes(xmin=\"2020 12\", xmax=\"2021 3\", \n                          ymin =0, ymax=max(Total+(Total/100*10))), \n            fill = \"lightskyblue\", alpha = 0.4, colour = NA)+\n  geom_line(alpha = 0.6, size = 1.5)+\n  scale_x_discrete(breaks = c(\"2019 1\", \"2019 7\",\"2019 1\",\"2020 1\",\"2020 7\",\"2021 1\",\"2021 7\"),\n                   labels = c(\"2019 1\", \"2019 7\",\"2019 1\",\"2020 1\",\"2020 7\",\"2021 1\",\"2021 7\"))+\n  labs(title= \"\", y=\"Fuss pro Monat\", x = \"Jahr\")+\n  theme_linedraw(base_size = 15)+\n  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))\n```\n\n::: {.cell-output-display}\n![](6_Deskriptive_Analysen_Uebung_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n\n```{.r .cell-code}\n# 3.2 Wochengang ####\n\n# mean / d / phase\nmean_phase_wd <- depo_d %>% \n  group_by(Wochentag, Phase) %>% \n  summarise(Total = mean(Total))\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n`summarise()` has grouped output by 'Wochentag'. You can override using the\n`.groups` argument.\n```\n:::\n\n```{.r .cell-code}\n#plot\nggplot(data = depo_d)+\n  geom_boxplot(mapping = aes(x= Wochentag, y = Total, fill = Phase))+\n  labs(title=\"\", y= \"Anzahl pro Tag\")+\n  scale_fill_manual(values = c(\"royalblue\", \"red4\", \"orangered\", \"gold2\"))+\n  theme_classic(base_size = 15)+\n  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1),\n        legend.title = element_blank())\n```\n\n::: {.cell-output-display}\n![](6_Deskriptive_Analysen_Uebung_files/figure-html/unnamed-chunk-3-2.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Statistik: Unterschied WE und WO während Lockdown 1\nt.test(depo_d$Total[depo_d$Phase == \"Lockdown_1\" & depo_d$Wochenende==\"Werktag\"], \n       depo_d$Total [depo_d$Phase == \"Lockdown_1\" & depo_d$Wochenende==\"Wochenende\"])\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in t.test.default(depo_d$Total[depo_d$Phase == \"Lockdown_1\" & depo_d$Wochenende == : not enough 'x' observations\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# 3.3 Tagesgang ####\n# Bei diesen Berechnungen wird jeweils der Mittelwert pro Stunde berechnet. \n# wiederum nutzen wir dafuer \"pipes\"\nMean_h <- depo %>% \n  group_by(Wochentag, Stunde, Phase) %>% \n  summarise(Total = mean(Total)) \n```\n\n::: {.cell-output .cell-output-stderr}\n```\n`summarise()` has grouped output by 'Wochentag', 'Stunde'. You can override\nusing the `.groups` argument.\n```\n:::\n\n```{.r .cell-code}\n# transformiere fuer Plotting\nMean_h<- reshape2::melt(Mean_h,measure.vars = c(\"Total\"),\n                             value.name = \"Total\",variable.name = \"Gruppe\")\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in loadNamespace(x): there is no package called 'reshape2'\n```\n:::\n\n```{.r .cell-code}\n# Plotte den Tagesgang, unterteilt nach Wochentagen\n\n# Normal\ntag_norm <- ggplot(subset(Mean_h, Phase %in% c(\"Normal\")), \n                     mapping=aes(x = Stunde, y = Total, colour = Wochentag, linetype = Wochentag))+\n  geom_line(size = 2)+\n  scale_colour_viridis_d()+\n  scale_linetype_manual(values = c(rep(\"solid\", 5),  \"twodash\", \"twodash\"))+\n  scale_x_continuous(breaks = c(seq(0, 23, by = 2)), labels = c(seq(0, 23, by = 2)))+\n  labs(x=\"Uhrzeit [h]\", y= \"∅ Fussganger_Innen / h\", title = \"\")+\n  lims(y = c(0,25))+\n  theme_linedraw(base_size = 15)+\n  theme(legend.position = \"right\")\n\n# Lockdown 1\n\ntag_lock_1 <- ggplot(subset(Mean_h, Phase %in% c(\"Lockdown_1\")), \n                     mapping=aes(x = Stunde, y = Total, colour = Wochentag, linetype = Wochentag))+\n  geom_line(size = 2)+\n  scale_colour_viridis_d()+\n  scale_linetype_manual(values = c(rep(\"solid\", 5), \"twodash\", \"twodash\"))+\n  scale_x_continuous(breaks = c(seq(0, 23, by = 2)), labels = c(seq(0, 23, by = 2)))+\n  labs(x=\"Uhrzeit [h]\", y= \"∅ Fussganger_Innen / h\", title = \"\")+\n  lims(y = c(0,25))+\n  theme_linedraw(base_size = 15)+\n  theme(legend.position = \"right\")\n\n# Lockdown 2\ntag_lock_2 <- ggplot(subset(Mean_h, Phase %in% c(\"Lockdown_2\")), \n                     mapping=aes(x = Stunde, y = Total, colour = Wochentag, linetype = Wochentag))+\n  geom_line(size = 2)+\n  scale_colour_viridis_d()+\n  scale_linetype_manual(values = c(rep(\"solid\", 5), \"twodash\", \"twodash\"))+\n  scale_x_continuous(breaks = c(seq(0, 23, by = 2)), labels = c(seq(0, 23, by = 2)))+\n  labs(x=\"Uhrzeit [h]\", y= \"∅ Fussganger_Innen / h\", title = \"\")+\n  lims(y = c(0,25))+\n  theme_linedraw(base_size = 15)+\n  theme(legend.position = \"right\")\n\n# Covid\ntag_covid <- ggplot(subset(Mean_h, Phase %in% c(\"Covid\")), \n                     mapping=aes(x = Stunde, y = Total, colour = Wochentag, linetype = Wochentag))+\n  geom_line(size = 2)+\n  scale_colour_viridis_d()+\n  scale_linetype_manual(values = c(rep(\"solid\", 5), \"twodash\", \"twodash\"))+\n  scale_x_continuous(breaks = c(seq(0, 23, by = 2)), labels = c(seq(0, 23, by = 2)))+\n  labs(x=\"Uhrzeit [h]\", y= \"∅ Fussganger_Innen / h\", title = \"\")+\n  lims(y = c(0,25))+\n  theme_linedraw(base_size = 15)+\n  theme(legend.position = \"right\")\n\n# Arrange und Export Tagesgang\nggarrange(tag_lock_1+            # plot 1 aufrufen\n            rremove(\"x.text\")+   # plot 1 braucht es nicht alle Achsenbeschriftungen\n            rremove(\"x.title\"),            \n          tag_lock_2+            # plot 2 aufrufen\n            rremove(\"y.text\")+   # bei plot 2 brauchen wir keine Achsenbeschriftung\n            rremove(\"y.title\")+\n            rremove(\"x.text\")+\n            rremove(\"x.title\"),\n          tag_norm,\n          tag_covid+\n            rremove(\"y.text\")+   \n            rremove(\"y.title\"),\n          ncol = 2, nrow = 2,    # definieren, wie die plots angeordnet werden\n          heights = c(0.9, 1),  # beide plots sind wegen der fehlenden Beschriftung nicht gleich hoch\n          widths = c(1,0.9),    \n          labels = c(\"a) Lockdown 1\", \"b) Lockdown 2\", \"c) Normal\", \"d) Covid\"),\n          label.x = 0.1,        # wo stehen die Plottitel\n          label.y = 0.99,\n          common.legend = TRUE, legend = \"bottom\") # wir brauchen nur eine Legende, unten\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Removed 24 row(s) containing missing values (geom_path).\nRemoved 24 row(s) containing missing values (geom_path).\nRemoved 24 row(s) containing missing values (geom_path).\nRemoved 24 row(s) containing missing values (geom_path).\nRemoved 24 row(s) containing missing values (geom_path).\nRemoved 24 row(s) containing missing values (geom_path).\nRemoved 24 row(s) containing missing values (geom_path).\nRemoved 24 row(s) containing missing values (geom_path).\n```\n:::\n\n::: {.cell-output-display}\n![](6_Deskriptive_Analysen_Uebung_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n\n```{.r .cell-code}\n# 3.4 Kennzahlen ####\ntotal_phase <- depo_d %>% \n  # gruppiere nach Phasen inkl. Normal. Diese Levels haben wir bereits definiert\n  group_by(Phase) %>% \n  summarise(Total = sum(Total),\n            IN = sum(Fuss_IN),\n            OUT = sum(Fuss_OUT))\n\n# mean besser Vergleichbar, da Zeitreihen unterschiedlich lange\nmean_phase_d <- depo_d %>% \n  group_by(Phase) %>% \n  summarise(Total = mean(Total),\n            IN = mean(Fuss_IN),\n            OUT = mean(Fuss_OUT))\n# berechne prozentuale Richtungsverteilung\nmean_phase_d <- mean_phase_d %>% \n  mutate(Proz_IN = round(100/Total*IN, 1)) %>% # berechnen und auf eine Nachkommastelle runden\n  mutate(Proz_OUT = round(100/Total*OUT,1))\n\n# selektiere absolute Zahlen\n# behalte rel. Spalten (nur die relativen Prozentangaben)\nmean_phase_d_abs <- mean_phase_d[,-c(2,5,6), drop=FALSE]\n# transformiere fuer Plotting\nmean_phase_d_abs <- reshape2::melt(mean_phase_d_abs, \n                                     measure.vars = c(\"IN\",\"OUT\"),\n                                     value.name = \"Durchschnitt\",variable.name = \"Gruppe\")\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in loadNamespace(x): there is no package called 'reshape2'\n```\n:::\n\n```{.r .cell-code}\n# selektiere relative Zahlen\n# behalte rel. Spalten (nur die relativen Prozentangaben)\nmean_phase_d_proz <- mean_phase_d[,-c(2:4), drop=FALSE]\n# transformiere fuer Plotting\nmean_phase_d_proz <- reshape2::melt(mean_phase_d_proz, \n                                 measure.vars = c(\"Proz_IN\",\"Proz_OUT\"),\n                                 value.name = \"Durchschnitt\",variable.name = \"Gruppe\")\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in loadNamespace(x): there is no package called 'reshape2'\n```\n:::\n\n```{.r .cell-code}\n# Visualisierung abs\nabs <- ggplot(data = mean_phase_d_abs, mapping = aes(x = Gruppe, y = Durchschnitt, fill = Phase))+\n  geom_col(position = \"dodge\", width = 0.8)+\n  scale_fill_manual(values = c(\"royalblue\", \"red4\", \"orangered\", \"gold2\"), name = \"Phase\")+\n  scale_x_discrete(labels = c(\"IN\", \"OUT\"))+\n  labs(y = \"Durchschnitt [mean]\", x= \"Bewegungsrichtung\")+\n  theme_classic(base_size = 15)+\n  theme(legend.position = \"bottom\")\n\n# Visualisierung %\nproz <- ggplot(data = mean_phase_d_proz, mapping = aes(x = Gruppe, y = Durchschnitt, fill = Phase))+\n  geom_col(position = \"dodge\", width = 0.8)+\n  scale_fill_manual(values = c(\"royalblue\", \"red4\", \"orangered\", \"gold2\"), name = \"Phase\")+\n  scale_x_discrete(labels = c(\"IN\", \"OUT\"))+\n  labs(y = \"Durchschnitt [%]\", x= \"Bewegungsrichtung\")+\n  theme_classic(base_size = 15)+\n  theme(legend.position = \"bottom\")\n\n# Arrange und Export Verteilung\nggarrange(abs,            # plot 1 aufrufen\n          proz,            # plot 2 aufrufen\n          ncol = 2, nrow = 1,    # definieren, wie die plots angeordnet werden\n          heights = c(1),        # beide sind bleich hoch\n          widths = c(1,0.95),    # plot 2 ist aufgrund der fehlenden y-achsenbesch. etwas schmaler\n          labels = c(\"a) Absolute Verteilung\", \"b) Relative Verteilung\"),\n          label.x = 0,        # wo stehen die labels\n          label.y = 1.0,\n          common.legend = TRUE, legend = \"bottom\") # wir brauchen nur eine Legende, unten\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in FUN(X[[i]], ...): object 'Durchschnitt' not found\n```\n:::\n:::\n\n\n# Aufgabe 1: Verlauf der Besuchszahlen / m\n\nNachdem wir die Projektstruktur aufgebaut haben und die Daten vorbereitet sind, machen wir uns an die deskriptive Analyse. Dies macht eigentlich immer Sinn. Bevor mach sich an die schliessende Statistik macht, muss man ein \"Gefühl\" für die Daten bekommen. Dies funktioniert am einfachsten mit deskriptiven, explorativen Analysen.\n\nWir interessieren uns in den Analysen grundsätzlich für 4 Zeitabschnitte:\n\n1) Normal (vom Start der Erhebungen bis vor dem ersten Lockdown)\n2) Lockdown 1\n3) Lockdown 2\n4) Seit Covid, aber nicht während eines Lockdowns\n\nWir haben relativ lange Zeitreihen. Zur Visualisierung des generellen Trends greifen wir darum auf die aggregierten Daten zurück - das macht den Plot übersichtlicher und damit aussagekräftiger.\n\n- Plottet den Verlauf der monatlichen Besuchszahlen an eurer Zählstelle. Auf der x-Achse steht dabei dabei Jahr und Monat (gespeichert im df _depo_m_), auf der y-Achse die monatlichen Besuchszahlen. Zeichnet auch die beiden Lockdown ein (Hinweis: rundet das Start- und Enddatum des Lockdowns auf den Monat, da im Plot die monatlichen Zahlen gezeigt werden).\n\nHaltet euch dabei an untenstehenden Plot:\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](6_Deskriptive_Analysen_Uebung_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\n__Hinweis:__ \n- Nutzt zum plotten __ggplot()__\n- folgende Codeschnipsel helfen euch:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = depo_m, mapping = aes(Ym, Total, group = 1))+ # group 1 braucht R, dass aus den Einzelpunkten ein Zusammenhang hergestellt wird\n  # zeichne Lockdown 1; ein einfaches Rechteck. bestimme mit min und max die Dimensionen\n  geom_rect(mapping = aes(xmin=\"2020 3\", xmax=\"2020 5\",\n                          ymin =0, ymax=max(Total+(Total/100*10))), # das Rechteck soll 10 % grösser als die maximale Besuchszahl sein \n            fill = \"lightskyblue\", alpha = 0.4, colour = NA)+\n  # zeichne Lockdown 2\n    ...+\n  # zeichne die Linie\n  geom_line(...)+\n  # bestimme manuell, wo auf der x-Achse die breaks sind und wie diese angeschrieben werden sollen\n  scale_x_discrete(breaks = c(\"...\", \"...\", ...),\n                   labels = c(\"...\", \"...\", ...))+\n  theme_linedraw(base_size = 15)+\n  ...\n```\n:::\n\n\n- Exportiert euren Plot mit __ggsave()__ nach __results__. Breite = 20, Höhe = 10, Einheiten = cm, dpi = 1000\n\n# Aufgabe 2: Wochengang\n\nNachdem wir nun wissen, wie sich die Besuchszahlen während der Untersuchungsdauer monatlich entwickelt haben, möchten wir genauer untersuchen, wie sich die Zahlen je nach Phase (Normal, Lockdown 1. Lockdown 2 und Covid) auf die Wochentage verteilen. \n\n## 2a)\n\n- Berechnet zuerst die Totale Anzahl pro Wochentag pro Phase.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean_phase_wd <- depo_d %>% \n  group_by(...) %>% \n  ...\n```\n:::\n\n\n- Speichert das als .csv\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwrite.csv(mean_phase_wd, \"results/mean_phase_wd.csv\")\n```\n:::\n\n\n## 2b)\n\n- Erstellt einen Boxplot nach untenstehender Vorgabe:\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](6_Deskriptive_Analysen_Uebung_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\n\n__Hinweis:__ \n- Nutzt zum plotten __ggplot()__\n- folgende Codeschnipsel helfen euch:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = depo_d)+\n  geom_boxplot(mapping = aes(x= Wochentag, y = Total, fill = Phase))+\n  ...\n```\n:::\n\n\n- Exportiert auch diesen Plot mit __ggsave()__. Welche Breite und Höhe passt hier?\n\n## 2c)\n\nSind die Unterschiede zwischen Werktag und Wochenende wirklich signifikant? Falls ja, in allen Phasen oder nur während bestimmter?\n\n- Prüft das pro Phase mit einem einfachen t.test.\n\n# Aufgabe 3: Tagesgang\n\nVom Grossen zum Kleinen, von der Übersicht ins Detail. Jetzt widmen wir uns dem Tagesgang, das heisst der Verteilung der Besuchenden auf die 24 Tagesstunden je nach Phase.\n\n## 3a)\n\n- Berechnet zuerst den Mittelwert der Totalen Besuchszahlen pro Wochentag pro Stunde pro Phase. (ganz ähnlich wie unter 2a) und speichert das df unter __Mean_h__.\n\nggplots haben Daten lieber im Format long als wide. \n\n## 3b)\n\n- Plottet den Tagesgang, unterteilt nach den 7 Wochentagen nun für unsere 4 Phasen.\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Removed 24 row(s) containing missing values (geom_path).\n```\n:::\n\n::: {.cell-output-display}\n![](6_Deskriptive_Analysen_Uebung_files/figure-html/unnamed-chunk-12-1.png){width=672}\n:::\n:::\n\n\nFür die Phase \"Normal\" benutze ich folgenden Codeschnipsel. Speichert den Plot ab (hier: __tag_norm__).\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntag_norm <- ggplot(subset(Mean_h, Phase %in% c(\"Normal\")), \n                     mapping=aes(x = Stunde, y = Total, colour = Wochentag, linetype = Wochentag))+\n  ...\n```\n:::\n\n\n__Hinweis:__ Achtet darauf, dass die Skalierung der y-Achse bei allen 4 Plots dieselbe ist (z.B. immer vom 0 bis 25). \n\n## 3c)\n\n- Arrangiert die vier erstellten Plots und speichert das Resultat. Das ist etwas tricky, darum hier der vollständige Code.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Arrange und Export Tagesgang\nggarrange(tag_lock_1+            # plot 1 aufrufen\n            rremove(\"x.text\")+   # plot 1 braucht es nicht alle Achsenbeschriftungen\n            rremove(\"x.title\"),            \n          tag_lock_2+            # plot 2 aufrufen\n            rremove(\"y.text\")+   # bei plot 2 brauchen wir keine Achsenbeschriftung\n            rremove(\"y.title\")+\n            rremove(\"x.text\")+\n            rremove(\"x.title\"),\n          tag_norm,\n          tag_covid+\n            rremove(\"y.text\")+   \n            rremove(\"y.title\"),\n          ncol = 2, nrow = 2,    # definieren, wie die plots angeordnet werden\n          heights = c(0.9, 1),  # beide plots sind wegen der fehlenden Beschriftung nicht gleich hoch\n          widths = c(1,0.9),    \n          labels = c(\"a) Lockdown 1\", \"b) Lockdown 2\", \"c) Normal\", \"d) Covid\"),\n          label.x = 0.1,        # wo stehen die Plottitel\n          label.y = 0.99,\n          common.legend = TRUE, legend = \"bottom\") # wir brauchen nur eine Legende, unten\n\nggsave(\"Tagesgang.png\", width=25, height=25, units=\"cm\", dpi=1000,\n       path = \"results/\")\n```\n:::\n\n\n# Aufgabe 4: Kennzahlen\n\nSchliesslich berechnen wir noch einige Kennzahlen (Anzahl Passagen, Richtungsverteilung, ...).\n\n## 4a)\n\n- Gruppiert nach Phase und berechnet dieses mal die Summe (nicht den Durchschnitt) Total, IN und OUT (ähnlich wie in 2a und 3a).\n\n- Speichert das Ergebnis als .csv\n\n## 4b) \n\nDie Zeitreihen der 4 Phasen unterscheiden sich deutlich voneinander. Totale Summen sind da kaum miteinander vergleichbar, besser eignet sich der Durchschnitt oder der Median.\n\n- Gruppiert nach Phase und berechnet den Durchschnitt Total, IN und OUT und speichert das df unter __mean_phase_d__.\n\n- Ergänzt das mit der prozentualen Richtungsverteilung\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean_phase_d <- mean_phase_d %>% \n  mutate(Proz_IN = round(100/Total*IN, 1)) %>% # berechnen und auf eine Nachkommastelle runden\n  ...\n```\n:::\n\n\n- Speichert das Ergebnis als .csv\n\n- Selektiert nun die absoluten Zahlen im df __mean_phase_d__ sowie die relativen und speichert das jeweils in einem df __mean_phase_d_abs__ und __mean_phase_d_proz__.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean_phase_d_abs <- mean_phase_d %>% dplyr::select(-c(Total, Proz_IN, Proz_OUT))\n```\n:::\n\n\n- transformiert beide df mittels __pivot_longer()__ von wide zu long:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean_phase_d_abs <- pivot_longer(mean_phase_d_abs, cols = c(\"IN\",\"OUT\"), \n             names_to = \"Gruppe\", values_to = \"Durchschnitt\")\n```\n:::\n\n\n## 4c)\n\nNun visualisieren wie die Verteilung der absoluten und der relativen Zahlen nach Phasen in einem Barplot.\n\n- Erstellt je einen Plot zu den absoluten und den relativen Zahlen nach den unterstehenden Vorgaben und speichert beide Plots im Environment:\n\n\n::: {.cell}\n::: {.cell-output .cell-output-error}\n```\nError in FUN(X[[i]], ...): object 'Durchschnitt' not found\n```\n:::\n\n::: {.cell-output .cell-output-error}\n```\nError in FUN(X[[i]], ...): object 'Durchschnitt' not found\n```\n:::\n:::\n\n\n- Arrangiert beide Plots nebeneinander und exportiert das Ergebnis (Arrangieren siehe 3c). \n\n\n\n::: {.cell}\n\n:::\n",
    "supporting": [
      "6_Deskriptive_Analysen_Uebung_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}