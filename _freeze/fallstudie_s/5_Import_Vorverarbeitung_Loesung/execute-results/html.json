{
  "hash": "66e7df5902e224e0e54a55cdd12d2f6a",
  "result": {
    "markdown": "\n# 5. Lösung\n\n\n\n\n::: {.cell}\n\n:::\n\n\n\n\n\n\n::: {.cell layout-align=\"left\"}\n\n:::\n\n\n# Aufgabe 1: Zähldaten\n\n\n::: {.cell layout-align=\"left\"}\n\n```{.r .cell-code}\n#.################################################################################################\n# 1. DATENIMPORT #####\n#.################################################################################################\n\n# Beim Daten einlesen koennen sogleich die Datentypen und erste Bereinigungen vorgenommen werden\n\n# 1.1 Zaehldaten ####\n# Die Zaehldaten des Wildnispark wurden vorgaengig bereinigt. z.B. wurden Stundenwerte \n# entfernt, an denen am Zaehler Wartungsarbeiten stattgefunden haben.\n\n# lese die Daten mithilfe der Bibliothek data.table ein (alternative zu read_csv und dergleichen). \n# Je nach Bedarf muss der Speicherort sowie der Dateiname angepasst werden\ndepo <- fread(here(\"data\",\"211_sihlwaldstrasse_2017_2021.csv\"))\n\n# Hinweis zu den Daten:\n# In hourly analysis format, the data at 11:00 am corresponds to the counts saved between \n# 11:00 am and 12:00 am.\n\n# Anpassen der Datentypen und erstes Sichten\nstr(depo)\n\ndepo <- depo %>%\n  mutate(Datum_Uhrzeit = as.character(DatumUhrzeit)) %>%\n  separate(Datum_Uhrzeit, into = c(\"Datum\", \"Zeit\"), sep = \" \")%>%\n  mutate(Datum = as.Date(Datum, format = \"%d.%m.%Y\")) %>% \n  # Schneide das df auf den gewuenschten Zeitraum zu\n  filter(Datum >= depo_start, Datum <=  depo_end) # das Komma hat die gleiche Funktion wie ein &\n\n# In dieser Auswertung werden nur Velos betrachtet!\ndepo <- depo[,-c(1,4,5), drop=FALSE] # mit diesem Befehl lassen wir Spalten \"fallen\", \n                                     # aendern aber nichts an der Form des data.frames\n\n# Berechnen des Totals, da dieses in den Daten nicht vorhanden ist\ndepo <- depo%>%\n  mutate(Total = Fuss_IN + Fuss_OUT)\n\n# Entferne die NA's in dem df.\ndepo <- na.omit(depo)\n```\n:::\n\n\n# Aufgabe 2: Meteodaten\n\n\n::: {.cell layout-align=\"left\"}\n\n```{.r .cell-code}\n# 1.2 Meteodaten ####\n# Einlesen\nmeteo <- fread(here(\"data\",\"order_97149_data.txt\"))\n\n# Datentypen setzen\n# Das Datum wird als Integer erkannt. Zuerst muss es in Text umgewaldelt werden aus dem dann\n# das eigentliche Datum herausgelesen werden kann\nmeteo <- transform(meteo, time = as.Date(as.character(time), \"%Y%m%d\"))\n\n# Die eigentlichen Messwerte sind alle nummerisch\nmeteo <- meteo%>%\n  mutate(tre200jx = as.numeric(tre200jx))%>%\n  mutate(rre150j0 = as.numeric(rre150j0))%>%\n  mutate(sremaxdv = as.numeric(sremaxdv)) %>% \n  filter(time >= depo_start, time <=  depo_end) # schneide dann auf Untersuchungsdauer\n\n# Was ist eigentlich Niederschlag:\n# https://www.meteoschweiz.admin.ch/home/wetter/wetterbegriffe/niederschlag.html\n\n# Filtere Werte mit NA\nmeteo <- meteo %>%\n  filter(!is.na(stn)) %>%\n  filter(!is.na(time))%>%\n  filter(!is.na(tre200jx))%>%\n  filter(!is.na(rre150j0))%>%\n  filter(!is.na(sremaxdv))\n# Pruefe ob alles funktioniert hat\nstr(meteo)\nsum(is.na(meteo)) # zeigt die Anzahl NA's im data.frame an\n```\n:::\n\n\n# Aufgabe 3: Datenvorverarbeitung (Mutationen)\n\n\n::: {.cell layout-align=\"left\"}\n\n```{.r .cell-code}\n#.################################################################################################\n# 2. VORBEREITUNG DER DATEN #####\n#.################################################################################################\n\n# 2.1 Convinience Variablen ####\n# fuege dem Dataframe (df) die Wochentage hinzu\ndepo <- depo %>% \n  mutate(Wochentag = weekdays(Datum)) %>% \n  # R sortiert die Levels aplhabetisch. Da das in unserem Fall aber sehr unpraktisch ist,\n  # muessen die Levels manuell manuell bestimmt werden\n  mutate(Wochentag = base::factor(Wochentag, \n                            levels = c(\"Montag\", \"Dienstag\", \"Mittwoch\", \n                                       \"Donnerstag\", \"Freitag\", \"Samstag\", \"Sonntag\"))) %>% \n  # Werktag oder Wochenende hinzufuegen\n  mutate(Wochenende = if_else(Wochentag == \"Montag\" | Wochentag == \"Dienstag\" | \n                           Wochentag == \"Mittwoch\" | Wochentag == \"Donnerstag\" | \n                           Wochentag == \"Freitag\", \"Werktag\", \"Wochenende\"))%>%\n  #Kalenderwoche hinzufuegen\n  mutate(KW= week(Datum))%>%\n  # monat und Jahr\n  mutate(Monat = month(Datum)) %>% \n  mutate(Jahr = year(Datum))\n\n# Lockdown \n# Hinweis: ich mache das nachgelagert, da ich die Erfahrung hatte, dass zu viele \n# Operationen in einem Schritt auch schon mal durcheinander erzeugen koennen.\n# Hinweis II: Wir packen alle Phasen (normal, die beiden Lockdowns und Covid aber ohne Lockdown)\n# in eine Spalte --> long ist schoener als wide\ndepo <- depo %>%\nmutate(Phase = if_else(Datum >= lock_1_start_2020 & Datum <= lock_1_end_2020,\n                          \"Lockdown_1\",\n                       if_else(Datum >= lock_2_start_2021 & Datum <= lock_2_end_2021,\n                               \"Lockdown_2\",\n                               if_else(Datum < lock_1_start_2020,\n                                  \"Normal\", \"Covid\"))))\n\n# hat das gepklappt?!\nunique(depo$Phase)\n\n# aendere die Datentypen\ndepo <- depo %>% \n  mutate(Wochenende = as.factor(Wochenende)) %>% \n  mutate(KW = factor(KW)) %>% \n  # mit factor() koennen die levels direkt einfach selbst definiert werden.\n  # wichtig: speizfizieren, dass aus R base, ansonsten kommt es zu einem \n  # mix-up mit anderen packages\n  mutate(Phase = base::factor(Phase, levels = c(\"Normal\", \"Lockdown_1\", \"Lockdown_2\", \"Covid\")))\n\nstr(depo)\n  \n# Fuer einige Auswertungen muss auf die Stunden als nummerischer Wert zurueckgegriffen werden\ndepo$Stunde <- as.numeric(format(as.POSIXct(depo$Zeit,format=\"%H:%M\"),\"%H\"))\n\n# Die Daten wurden kalibriert. Wir runden sie fuer unserer Analysen auf Ganzzahlen\ndepo$Total <- round(depo$Total, digits = 0)\ndepo$Fuss_IN <- round(depo$Fuss_IN, digits = 0)\ndepo$Fuss_OUT <- round(depo$Fuss_OUT, digits = 0)\n```\n:::\n\n\n# Aufgabe 4: Aggregierung der Stundendaten\n\n\n::: {.cell layout-align=\"left\"}\n\n```{.r .cell-code}\n# 2.3 Aggregierung der Stundendaten zu ganzen Tagen ####\n# Zur Berechnung von Kennwerten ist es hilfreich, wenn neben den Stundendaten auch auf Ganztagesdaten\n# zurueckgegriffen werden kann\n# hier werden also pro Nutzergruppe und Richtung die Stundenwerte pro Tag aufsummiert\ndepo_d <- depo %>% \n  group_by(Datum, Wochentag, Wochenende, KW, Monat, Jahr, Phase) %>% \n  summarise(Total = sum(Fuss_IN + Fuss_OUT), \n            Fuss_IN = sum(Fuss_IN),\n            Fuss_OUT = sum(Fuss_OUT)) \n# Wenn man die Convinience Variablen als grouping variable einspeisst, dann werden sie in \n# das neue df uebernommen und muessen nicht nochmals hinzugefuegt werden\n\n# pruefe das df\nhead(depo_d)\n\n# Gruppiere die Werte nach Monat\ndepo_m <- depo %>% \n  group_by(Jahr, Monat) %>% \n  summarise(Total = sum(Total)) \n# sortiere das df aufsteigend (nur das es sicher stimmt)\ndepo_m <- as.data.frame(depo_m)\ndepo_m[\n  with(depo_m, order(Jahr, Monat)),]\n# mache dann aus Jahr und Monat faktoren\ndepo_m <- depo_m %>% \n  mutate(Jahr = as.factor(Jahr)) %>% \n  mutate(Monat = as.factor(Monat)) %>% \n  mutate(Ym = paste(Jahr, Monat)) %>% # und mache eine neue Spalte, in der Jahr und\n  mutate(Ym= factor(Ym, levels=unique(Ym))) # Monat in zusammen sind\n\n# Beispiele pruefen der Daten:\n\n# Verteilung mittels Histogram pruefen\nhist(depo$Total[!depo$Total==0] , breaks = 100) \n```\n\n::: {.cell-output-display}\n![](5_Import_Vorverarbeitung_Loesung_files/figure-html/unnamed-chunk-7-1.png){fig-align='left' width=672}\n:::\n\n```{.r .cell-code}\n# hier schliesse ich die Nuller aus der Visualisierung aus\n\n# Verteilung mittels Scatterplot pruefen\nplot(x=depo$Datum, y=depo$Total)\n```\n\n::: {.cell-output-display}\n![](5_Import_Vorverarbeitung_Loesung_files/figure-html/unnamed-chunk-7-2.png){fig-align='left' width=672}\n:::\n\n```{.r .cell-code}\n# Temperaturmaximum\nggplot(data=meteo, mapping=aes(x=time, y=tre200jx))+\n  geom_point()+\n  geom_smooth(col=\"red\")\n```\n\n::: {.cell-output-display}\n![](5_Import_Vorverarbeitung_Loesung_files/figure-html/unnamed-chunk-7-3.png){fig-align='left' width=672}\n:::\n:::\n",
    "supporting": [
      "5_Import_Vorverarbeitung_Loesung_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}