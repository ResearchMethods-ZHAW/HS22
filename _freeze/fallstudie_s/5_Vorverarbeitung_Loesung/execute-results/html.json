{
  "hash": "1ef753d7f64a9113de44c8044dcac1b0",
  "result": {
    "markdown": "# KW 43: Lösung Datenvorverarbeitung\n\n\n\n\n\n\n# Aufgabe 1: Zähldaten\n\n\n::: {.cell layout-align=\"left\"}\n\n```{.r .cell-code}\n# lese die Daten ein \n# Je nach Bedarf muss der Speicherort sowie der Dateiname angepasst werden\ndepo <- read.csv(\"./data/211_sihlwaldstrasse_2017_2021.csv\", sep = \";\")\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in file(file, \"rt\"): kann Verbindung nicht öffnen\n```\n:::\n\n```{.r .cell-code}\n# Hinweis zu den Daten:\n# In hourly analysis format, the data at 11:00 am corresponds to the counts saved between \n# 11:00 am and 12:00 am.\n\n# Anpassen der Datentypen und erstes Sichten\nstr(depo)\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in str(depo): Objekt 'depo' nicht gefunden\n```\n:::\n\n```{.r .cell-code}\ndepo <- depo %>%\n  mutate(Datum_Uhrzeit = as.character(DatumUhrzeit)) %>%\n  separate(Datum_Uhrzeit, into = c(\"Datum\", \"Zeit\"), sep = \" \")%>%\n  mutate(Datum = as.Date(Datum, format = \"%d.%m.%Y\")) #%>% \n```\n\n::: {.cell-output .cell-output-error}\n```\nError in mutate(., Datum_Uhrzeit = as.character(DatumUhrzeit)): Objekt 'depo' nicht gefunden\n```\n:::\n\n```{.r .cell-code}\n  # Schneide das df auf den gewuenschten Zeitraum zu\n  # filter(Datum >= depo_start, Datum <=  depo_end) # das Komma hat die gleiche Funktion wie ein &\n\n# In dieser Auswertung werden nur Personen zu Fuss betrachtet!\n# it select werden spalten ausgewaehlt oder eben fallengelassen\ndepo <- depo %>% dplyr::select(-c(Velo_IN, Velo_OUT))\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in dplyr::select(., -c(Velo_IN, Velo_OUT)): Objekt 'depo' nicht gefunden\n```\n:::\n\n```{.r .cell-code}\n# Berechnen des Totals, da dieses in den Daten nicht vorhanden ist\ndepo <- depo%>%\n  mutate(Total = Fuss_IN + Fuss_OUT)\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in mutate(., Total = Fuss_IN + Fuss_OUT): Objekt 'depo' nicht gefunden\n```\n:::\n\n```{.r .cell-code}\n# Entferne die NA's in dem df.\ndepo <- na.omit(depo)\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in na.omit(depo): Objekt 'depo' nicht gefunden\n```\n:::\n:::\n\n\n# Aufgabe 2: Meteodaten\n\n\n::: {.cell layout-align=\"left\"}\n\n```{.r .cell-code}\n# Einlesen\nmeteo <- read.csv(\"./data/order_97149_data.txt\", sep = \";\")\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in file(file, \"rt\"): kann Verbindung nicht öffnen\n```\n:::\n\n```{.r .cell-code}\n# Datentypen setzen\n# Das Datum wird als Integer erkannt. Zuerst muss es in Text umgewaldelt werden aus dem dann\n# das eigentliche Datum herausgelesen werden kann\nmeteo <- transform(meteo, time = as.Date(as.character(time), \"%Y%m%d\"))\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in transform(meteo, time = as.Date(as.character(time), \"%Y%m%d\")): Objekt 'meteo' nicht gefunden\n```\n:::\n\n```{.r .cell-code}\n# Die eigentlichen Messwerte sind alle nummerisch\nmeteo <- meteo%>%\n  mutate(tre200jx = as.numeric(tre200jx))%>%\n  mutate(rre150j0 = as.numeric(rre150j0))%>%\n  mutate(sremaxdv = as.numeric(sremaxdv)) %>% \n  filter(time >= depo_start, time <=  depo_end) # schneide dann auf Untersuchungsdauer\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in mutate(., tre200jx = as.numeric(tre200jx)): Objekt 'meteo' nicht gefunden\n```\n:::\n\n```{.r .cell-code}\n# Was ist eigentlich Niederschlag:\n# https://www.meteoschweiz.admin.ch/home/wetter/wetterbegriffe/niederschlag.html\n\n# Filtere Werte mit NA\nmeteo <- meteo %>%\n  filter(!is.na(stn)) %>%\n  filter(!is.na(time))%>%\n  filter(!is.na(tre200jx))%>%\n  filter(!is.na(rre150j0))%>%\n  filter(!is.na(sremaxdv))\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in filter(., !is.na(stn)): Objekt 'meteo' nicht gefunden\n```\n:::\n\n```{.r .cell-code}\n# Pruefe ob alles funktioniert hat\nstr(meteo)\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in str(meteo): Objekt 'meteo' nicht gefunden\n```\n:::\n\n```{.r .cell-code}\nsum(is.na(meteo)) # zeigt die Anzahl NA's im data.frame an\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in eval(expr, envir, enclos): Objekt 'meteo' nicht gefunden\n```\n:::\n:::\n\n\n# Aufgabe 3: Datenvorverarbeitung (Mutationen)\n\n\n::: {.cell layout-align=\"left\"}\n\n```{.r .cell-code}\n#.################################################################################################\n# 2. VORBEREITUNG DER DATEN #####\n#.################################################################################################\n\n# 2.1 Convinience Variablen ####\n# fuege dem Dataframe (df) die Wochentage hinzu\ndepo <- depo %>% \n  mutate(Wochentag = weekdays(Datum)) %>% \n  # R sortiert die Levels aplhabetisch. Da das in unserem Fall aber sehr unpraktisch ist,\n  # muessen die Levels manuell manuell bestimmt werden\n  mutate(Wochentag = base::factor(Wochentag, \n                            levels = c(\"Montag\", \"Dienstag\", \"Mittwoch\", \n                                       \"Donnerstag\", \"Freitag\", \"Samstag\", \"Sonntag\"))) %>% \n  # Werktag oder Wochenende hinzufuegen\n  mutate(Wochenende = if_else(Wochentag == \"Montag\" | Wochentag == \"Dienstag\" | \n                           Wochentag == \"Mittwoch\" | Wochentag == \"Donnerstag\" | \n                           Wochentag == \"Freitag\", \"Werktag\", \"Wochenende\"))%>%\n  #Kalenderwoche hinzufuegen\n  mutate(KW= isoweek(Datum))%>%\n  # monat und Jahr\n  mutate(Monat = month(Datum)) %>% \n  mutate(Jahr = year(Datum))\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in mutate(., Wochentag = weekdays(Datum)): Objekt 'depo' nicht gefunden\n```\n:::\n\n```{.r .cell-code}\n#Lockdown \n# Hinweis: ich mache das nachgelagert, da ich die Erfahrung hatte, dass zu viele \n# Operationen in einem Schritt auch schon mal durcheinander erzeugen koennen.\n# Hinweis II: Wir packen alle Phasen (normal, die beiden Lockdowns und Covid aber ohne Lockdown)\n# in eine Spalte --> long ist schoener als wide\ndepo <- depo %>%\n  mutate(Phase = if_else(Datum >= lock_1_start_2020 & Datum <= lock_1_end_2020,\n                         \"Lockdown_1\",\n                         if_else(Datum >= lock_2_start_2021 & Datum <= lock_2_end_2021,\n                                 \"Lockdown_2\",\n                                 if_else(Datum>= (lock_1_start_2020 - years(1)) & Datum < lock_1_start_2020,\n                                         \"Normal\", \n                                         if_else(Datum > lock_2_end_2021,\n                                                 \"Post\", \"Pre\")))))\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in mutate(., Phase = if_else(Datum >= lock_1_start_2020 & Datum <= : Objekt 'depo' nicht gefunden\n```\n:::\n\n```{.r .cell-code}\n# hat das gepklappt?!\nunique(depo$Phase)\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in unique(depo$Phase): Objekt 'depo' nicht gefunden\n```\n:::\n\n```{.r .cell-code}\n# aendere die Datentypen\ndepo <- depo %>% \n  mutate(Wochenende = as.factor(Wochenende)) %>% \n  mutate(KW = factor(KW)) %>% \n  # mit factor() koennen die levels direkt einfach selbst definiert werden.\n  # wichtig: speizfizieren, dass aus R base, ansonsten kommt es zu einem \n  # mix-up mit anderen packages\n  mutate(Phase = base::factor(Phase, levels = c(\"Pre\", \"Normal\", \"Lockdown_1\", \"Lockdown_2\", \"Post\")))\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in mutate(., Wochenende = as.factor(Wochenende)): Objekt 'depo' nicht gefunden\n```\n:::\n\n```{.r .cell-code}\nstr(depo)\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in str(depo): Objekt 'depo' nicht gefunden\n```\n:::\n\n```{.r .cell-code}\n# Fuer einige Auswertungen muss auf die Stunden als nummerischer Wert zurueckgegriffen werden\ndepo$Stunde <- as.numeric(format(as.POSIXct(depo$Zeit,format=\"%H:%M\"),\"%H\"))\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in h(simpleError(msg, call)): Fehler bei der Auswertung des Argumentes 'x' bei der Methodenauswahl für Funktion 'format': Objekt 'depo' nicht gefunden\n```\n:::\n\n```{.r .cell-code}\n# ersetze 0 Uhr mit 24 Uhr (damit wir besser rechnen können)\ndepo$Stunde[depo$Stunde == 0] <- 24\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in depo$Stunde[depo$Stunde == 0] <- 24: Objekt 'depo' nicht gefunden\n```\n:::\n\n```{.r .cell-code}\nunique(depo$Stunde)\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in unique(depo$Stunde): Objekt 'depo' nicht gefunden\n```\n:::\n\n```{.r .cell-code}\ntypeof(depo$Stunde)\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in typeof(depo$Stunde): Objekt 'depo' nicht gefunden\n```\n:::\n\n```{.r .cell-code}\n# Die Daten wurden kalibriert. Wir runden sie fuer unserer Analysen auf Ganzzahlen\ndepo$Total <- round(depo$Total, digits = 0)\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in eval(expr, envir, enclos): Objekt 'depo' nicht gefunden\n```\n:::\n\n```{.r .cell-code}\ndepo$Fuss_IN <- round(depo$Fuss_IN, digits = 0)\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in eval(expr, envir, enclos): Objekt 'depo' nicht gefunden\n```\n:::\n\n```{.r .cell-code}\ndepo$Fuss_OUT <- round(depo$Fuss_OUT, digits = 0)\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in eval(expr, envir, enclos): Objekt 'depo' nicht gefunden\n```\n:::\n\n```{.r .cell-code}\n# 2.2 Tageszeit hinzufuegen ####\n\n# Einteilung Standort Zuerich\nLatitude <- 47.38598\nLongitude <- 8.50806\n\n# Zur Berechnung der Tageslaege muessen wir zuerst den Start und das Ende der Sommer-\n# zeit definieren\n# https://www.schulferien.org/schweiz/zeit/zeitumstellung/\n\nSo_start_2017 <- as.Date(\"2017-03-26\") \nSo_end_2017 <- as.Date(\"2017-10-29\") \nSo_start_2018 <- as.Date(\"2018-03-25\") \nSo_end_2018 <- as.Date(\"2018-10-28\") \nSo_start_2019 <- as.Date(\"2019-03-31\") \nSo_end_2019 <- as.Date(\"2019-10-27\") \nSo_start_2020 <- as.Date(\"2020-03-29\")\nSo_end_2020 <- as.Date(\"2020-10-25\")\nSo_start_2021 <- as.Date(\"2021-03-28\")\nSo_end_2021 <- as.Date(\"2021-10-31\")\nSo_start_2022 <- as.Date(\"2022-03-27\")\nSo_end_2022 <- as.Date(\"2022-10-30\")\n\n# Welche Zeitzone haben wir eigentlich?\n# Switzerland uses Central European Time (CET) during the winter as standard time, \n# which is one hour ahead of Coordinated Universal Time (UTC+01:00), and \n# Central European Summer Time (CEST) during the summer as daylight saving time, \n# which is two hours ahead of Coordinated Universal Time (UTC+02:00).\n# https://en.wikipedia.org/wiki/Time_in_Switzerland\n\n# Was sind Astronomische Dämmerung und Golden Hour ueberhaupt?\n# https://sunrisesunset.de/sonne/schweiz/zurich-kreis-1-city/\n# https://www.rdocumentation.org/packages/suncalc/versions/0.5.0/topics/getSunlightTimes\n\n# Wir arbeiten mit folgenden Variablen:\n# \"nightEnd\" : night ends (morning astronomical twilight starts)\n# \"goldenHourEnd\" : morning golden hour (soft light, best time for photography) ends\n# \"goldenHour\" : evening golden hour starts\n# \"night\" : night starts (dark enough for astronomical observations)\n\nlumidata <-\n  getSunlightTimes(\n    date = seq.Date(depo_start, depo_end, by = 1),\n    keep = c(\"nightEnd\", \"goldenHourEnd\", \"goldenHour\", \"night\"),\n    lat = Latitude,\n    lon = Longitude,\n    tz = \"CET\")\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in getSunlightTimes(date = seq.Date(depo_start, depo_end, by = 1), : konnte Funktion \"getSunlightTimes\" nicht finden\n```\n:::\n\n```{.r .cell-code}\nlumidata <- lumidata %>% \n  mutate(Jahreszeit = ifelse(date >= So_start_2017 & date <=  So_end_2017 |\n                               date >= So_start_2018 & date <=  So_end_2018 |\n                               date >= So_start_2019 & date <=  So_end_2019 |\n                               date >= So_start_2020 & date <= So_end_2020 |\n                               date >= So_start_2021 & date <= So_end_2021, \n                             \"Sommerzeit\", \"Winterzeit\"))\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in mutate(., Jahreszeit = ifelse(date >= So_start_2017 & date <= : Objekt 'lumidata' nicht gefunden\n```\n:::\n\n```{.r .cell-code}\n# CH ist im Im Sommer CET + 1. \n# Darum auf alle relevanten Spalten eine Stunde addieren\n# hinweis: ich verzichte hier auf ifelse, da es einfacher und nachvollziehbarer scheint,\n# hier mit einem filter die betreffenden Spalten zu waehlen\nlumidata_So <- lumidata %>% \n  filter(Jahreszeit==\"Sommerzeit\") %>% \n  mutate(nightEnd = nightEnd + hours(1),\n         goldenHourEnd =  goldenHourEnd + hours(1),\n         goldenHour = goldenHour + hours(1),\n         night = night + hours(1))\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in filter(., Jahreszeit == \"Sommerzeit\"): Objekt 'lumidata' nicht gefunden\n```\n:::\n\n```{.r .cell-code}\nlumidata_Wi <- lumidata %>% \n  filter(Jahreszeit==\"Winterzeit\") \n```\n\n::: {.cell-output .cell-output-error}\n```\nError in filter(., Jahreszeit == \"Winterzeit\"): Objekt 'lumidata' nicht gefunden\n```\n:::\n\n```{.r .cell-code}\n# verbinde sommer- und winterzeit wieder\nlumidata <- rbind(lumidata_So, lumidata_Wi) %>% \n  arrange(date)\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in rbind(lumidata_So, lumidata_Wi): Objekt 'lumidata_So' nicht gefunden\n```\n:::\n\n```{.r .cell-code}\n# change data type\nlumidata$date <- as.Date(lumidata$date, format= \"%Y-%m-%d\")\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in as.Date(lumidata$date, format = \"%Y-%m-%d\"): Objekt 'lumidata' nicht gefunden\n```\n:::\n\n```{.r .cell-code}\n# drop unnecessary cols\nlumidata <- lumidata %>% dplyr::select(-lat, -lon)\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in dplyr::select(., -lat, -lon): Objekt 'lumidata' nicht gefunden\n```\n:::\n\n```{.r .cell-code}\n# jetzt haben wir alle noetigen Angaben zu Sonnenaufgang, Tageslaenge usw. \n# diese Angaben koennen wir nun mit unseren Zaehldaten verbinden:\ndepo <- left_join(depo,lumidata, by = c(\"Datum\" =\"date\"))\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in left_join(depo, lumidata, by = c(Datum = \"date\")): Objekt 'depo' nicht gefunden\n```\n:::\n\n```{.r .cell-code}\n# aendere alle Zeit- und Datumsangaben so, dass sie gleich sind und miteinander verrechnet werden können.\ndepo <- depo %>% \n  mutate(DatumUhrzeit = as.POSIXct(DatumUhrzeit, format = \"%d.%m.%Y %H:%M\")) %>% \n  mutate(nightEnd = as.POSIXct(nightEnd)) %>% \n  mutate(goldenHourEnd = as.POSIXct(goldenHourEnd)) %>% \n  mutate(goldenHourEnd = goldenHourEnd + hours(1)) %>% \n  mutate(goldenHour = as.POSIXct(goldenHour)) %>% \n  mutate(goldenHour = goldenHour - hours(1)) %>% \n  mutate(night = as.POSIXct(night))\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in mutate(., DatumUhrzeit = as.POSIXct(DatumUhrzeit, format = \"%d.%m.%Y %H:%M\")): Objekt 'depo' nicht gefunden\n```\n:::\n\n```{.r .cell-code}\n# im naechsten Schritt weise ich den Stunden die Tageszeiten Morgen, Tag, Abend und Nacht zu.\n# diese Zuweisung basiert auf der Einteilung gem. suncalc und eigener Definition.\ndepo <- depo%>%\n  mutate(Tageszeit = if_else(DatumUhrzeit >= nightEnd & DatumUhrzeit <= goldenHourEnd, \"Morgen\",\n                             ifelse(DatumUhrzeit > goldenHourEnd & DatumUhrzeit < goldenHour, \"Tag\",\n                                    ifelse(DatumUhrzeit >= goldenHour & DatumUhrzeit <= night,\n                                           \"Abend\",\n                                           \"Nacht\")))) %>%\n  mutate(Tageszeit = factor(Tageszeit, levels = c(\n    \"Morgen\", \"Tag\", \"Abend\", \"Nacht\")))\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in mutate(., Tageszeit = if_else(DatumUhrzeit >= nightEnd & DatumUhrzeit <= : Objekt 'depo' nicht gefunden\n```\n:::\n\n```{.r .cell-code}\n# # behalte die relevanten Var\ndepo <- depo %>% dplyr::select(-nightEnd, -goldenHourEnd, -goldenHour, -night)\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in dplyr::select(., -nightEnd, -goldenHourEnd, -goldenHour, -night): Objekt 'depo' nicht gefunden\n```\n:::\n\n```{.r .cell-code}\n#Plotte zum pruefn ob das funktioniert hat\np <- ggplot(depo, aes(y = Datum, color = Tageszeit, x = Stunde))+\n  geom_jitter()+\n  scale_color_manual(values=mycolors)\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in ggplot(depo, aes(y = Datum, color = Tageszeit, x = Stunde)): Objekt 'depo' nicht gefunden\n```\n:::\n\n```{.r .cell-code}\nplotly::ggplotly(p)\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in plotly::ggplotly(p): Objekt 'p' nicht gefunden\n```\n:::\n:::\n\n\n# Aufgabe 4: Aggregierung der Stundendaten\n\n\n::: {.cell layout-align=\"left\"}\n\n```{.r .cell-code}\n# 2.4 Aggregierung der Stundendaten zu ganzen Tagen ####\n# Zur Berechnung von Kennwerten ist es hilfreich, wenn neben den Stundendaten auch auf Ganztagesdaten\n# zurueckgegriffen werden kann\n# hier werden also pro Nutzergruppe und Richtung die Stundenwerte pro Tag aufsummiert\ndepo_d <- depo %>% \n  group_by(Datum, Wochentag, Wochenende, KW, Monat, Jahr, Phase) %>% \n  summarise(Total = sum(Fuss_IN + Fuss_OUT), \n            Fuss_IN = sum(Fuss_IN),\n            Fuss_OUT = sum(Fuss_OUT)) \n```\n\n::: {.cell-output .cell-output-error}\n```\nError in group_by(., Datum, Wochentag, Wochenende, KW, Monat, Jahr, Phase): Objekt 'depo' nicht gefunden\n```\n:::\n\n```{.r .cell-code}\n# Wenn man die Convinience Variablen als grouping variable einspeisst, dann werden sie in \n# das neue df uebernommen und muessen nicht nochmals hinzugefuegt werden\n# pruefe das df\nhead(depo_d)\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in h(simpleError(msg, call)): Fehler bei der Auswertung des Argumentes 'x' bei der Methodenauswahl für Funktion 'head': Objekt 'depo_d' nicht gefunden\n```\n:::\n\n```{.r .cell-code}\n# nun gruppieren wir nicht nur nach Tag sondern auch noch nach Tageszeit\ndepo_daytime <- depo %>% \n  group_by(Datum, Wochentag, Wochenende, KW, Monat, Jahr, Phase, Tageszeit) %>% \n  summarise(Total = sum(Fuss_IN + Fuss_OUT), \n            Fuss_IN = sum(Fuss_IN),\n            Fuss_OUT = sum(Fuss_OUT)) \n```\n\n::: {.cell-output .cell-output-error}\n```\nError in group_by(., Datum, Wochentag, Wochenende, KW, Monat, Jahr, Phase, : Objekt 'depo' nicht gefunden\n```\n:::\n\n```{.r .cell-code}\n# Gruppiere die Werte nach Monat\ndepo_m <- depo %>% \n  group_by(Jahr, Monat) %>% \n  summarise(Total = sum(Total)) \n```\n\n::: {.cell-output .cell-output-error}\n```\nError in group_by(., Jahr, Monat): Objekt 'depo' nicht gefunden\n```\n:::\n\n```{.r .cell-code}\n# sortiere das df aufsteigend (nur das es sicher stimmt)\ndepo_m <- as.data.frame(depo_m)\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in as.data.frame(depo_m): Objekt 'depo_m' nicht gefunden\n```\n:::\n\n```{.r .cell-code}\ndepo_m[\n  with(depo_m, order(Jahr, Monat)),]\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in eval(expr, envir, enclos): Objekt 'depo_m' nicht gefunden\n```\n:::\n\n```{.r .cell-code}\ndepo_m <- depo_m %>% \n  mutate(Ym = paste(Jahr, Monat)) %>% # und mache eine neue Spalte, in der Jahr und\n  mutate(Ym= lubridate::ym(Ym)) # formatiere als Datum\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in mutate(., Ym = paste(Jahr, Monat)): Objekt 'depo_m' nicht gefunden\n```\n:::\n\n```{.r .cell-code}\n# Gruppiere die Werte nach Monat und TAGESZEIT\ndepo_m_daytime <- depo %>% \n  group_by(Jahr, Monat, Tageszeit) %>% \n  summarise(Total = sum(Total)) \n```\n\n::: {.cell-output .cell-output-error}\n```\nError in group_by(., Jahr, Monat, Tageszeit): Objekt 'depo' nicht gefunden\n```\n:::\n\n```{.r .cell-code}\n# sortiere das df aufsteigend (nur das es sicher stimmt)\ndepo_m_daytime <- as.data.frame(depo_m_daytime)\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in as.data.frame(depo_m_daytime): Objekt 'depo_m_daytime' nicht gefunden\n```\n:::\n\n```{.r .cell-code}\ndepo_m_daytime[\n  with(depo_m_daytime, order(Jahr, Monat)),]\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in eval(expr, envir, enclos): Objekt 'depo_m_daytime' nicht gefunden\n```\n:::\n\n```{.r .cell-code}\ndepo_m_daytime <- depo_m_daytime %>% \n  mutate(Ym = paste(Jahr, Monat)) %>% # und mache eine neue Spalte, in der Jahr und\n  mutate(Ym= lubridate::ym(Ym)) # formatiere als Datum\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in mutate(., Ym = paste(Jahr, Monat)): Objekt 'depo_m_daytime' nicht gefunden\n```\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}