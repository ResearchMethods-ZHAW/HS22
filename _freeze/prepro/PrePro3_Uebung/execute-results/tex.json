{
  "hash": "47e4bb6447f13ed267191dc5dbce1df1",
  "result": {
    "markdown": "---\ndate: 2022-10-18\nlesson: PrePro3\nthema: Split-Apply-Combine\nindex: 2\n---\n\n\n\n# Prepro 3: Übung\n\n\n\n\n\n::: {.cell}\n\n:::\n\n\n\n\n\n\n## Aufgabe 1\n\nGegeben sei ein Datensatz \"[sensors_combined.csv](https://github.com/ResearchMethods-ZHAW/datasets/raw/main/prepro/sensors_combined.csv)\", mit den Temperaturwerten von drei verschiedenen Sensoren. Lade diesen Datensatz herunter,  importiere ihn als csv in R (als `sensors_combined`). \n\nFormatiere die `Datetime` Spalte in `POSIXct` um. Verwende dazu die Funktion `as.POSIXct` (lies mit `?strftime()` nochmal nach wie du das spezfische Format (die \"Schablone\") festlegen kannst.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(readr)\n\nsensors_combined <- read_csv(here(\"data\",\"sensors_combined.csv\"))\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nRows: 16 Columns: 4\n-- Column specification --------------------------------------------------------\nDelimiter: \",\"\nchr (1): Datetime\ndbl (3): sensor1, sensor2, sensor3\n\ni Use `spec()` to retrieve the full column specification for this data.\ni Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n:::\n\n```{.r .cell-code}\nsensors_combined$Datetime <- as.POSIXct(sensors_combined$Datetime, format = \"%d%m%Y_%H%M\")\n```\n:::\n\n\n\n## Aufgabe 2\n\nÜberführe die Tabelle in ein *langes* Format (verwende dazu die Funktion `pivot_longer` aus `tidyr`) und speichere den output als `sensors_long`. \n\nTipp: \n\n- im Argument `cols` kannst du entweder die Spalten auflisten, die \"pivotiert\" werden sollen. \n- Alternativ kannst du (mit vorangestelltem Minuszeichen, `-`) die Spalte, bezeichnen, die *nicht* pivotiert werden soll. \n- In beiden Fällen musst du die Spalten weder mit Anführungs- und Schlusszeichen noch mit dem `$`-Zeichen versehen.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyr)\n\n# Variante 1 (Spalten abwählen)\nsensors_long <- pivot_longer(sensors_combined, -Datetime) \n\n# Variante 2 (Spalten anwählen)\nsensors_long <- pivot_longer(sensors_combined, c(sensor1:sensor3))\n```\n:::\n\n\n\n## Aufgabe 3\n\nGruppiere `sensors_long` nach der neuen Spalte wo die Sensor-Information enthalten ist (default: `name`) mit `group_by` und berechne die mittlere Temperatur pro Sensor (`summarise`). Hinweis: Beide Funktionen sind Teil des Packages `dplyr`.\n\nDer Output sieht folgendermassen aus: \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttache Paket: 'dplyr'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nDie folgenden Objekte sind maskiert von 'package:stats':\n\n    filter, lag\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nDie folgenden Objekte sind maskiert von 'package:base':\n\n    intersect, setdiff, setequal, union\n```\n:::\n\n```{.r .cell-code}\nsensors_long %>%\n  group_by(name) %>%\n  summarise(temp_mean = mean(value, na.rm = TRUE))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 x 2\n  name    temp_mean\n  <chr>       <dbl>\n1 sensor1      14.7\n2 sensor2      12.0\n3 sensor3      14.4\n```\n:::\n:::\n\n\n\n## Aufgabe 4\n\nErstelle für `sensors_long` eine neue *convenience* Variabel `month` welche den Monat beinhaltet (Tipp: verwende dazu die Funktion `month` aus `lubridate`). Gruppiere nun nach `month` *und* Sensor und berechne die mittlere Temperatur. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(lubridate)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttache Paket: 'lubridate'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nDie folgenden Objekte sind maskiert von 'package:base':\n\n    date, intersect, setdiff, union\n```\n:::\n\n```{.r .cell-code}\nsensors_long %>%\n  mutate(month = month(Datetime)) %>%\n  group_by(month, name) %>%\n  summarise(temp_mean = mean(value, na.rm = TRUE))\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n`summarise()` has grouped output by 'month'. You can override using the\n`.groups` argument.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 x 3\n# Groups:   month [2]\n  month name    temp_mean\n  <dbl> <chr>       <dbl>\n1    10 sensor1     14.7 \n2    10 sensor2     12.7 \n3    10 sensor3     14.4 \n4    11 sensor1    NaN   \n5    11 sensor2      8.87\n6    11 sensor3    NaN   \n```\n:::\n:::\n\n\n\n## Aufgabe 5\n\nLade jetzt nochmal den Datensatz [wetter.csv](https://github.com/ResearchMethods-ZHAW/datasets/raw/main/prepro/weather.csv) (Quelle MeteoSchweiz) herunter und importiere ihn als CSV mit den Korrekten Spaltentypen (`stn` als `factor`, `time` als `POSIXct`, `tre200h0` als `double`).\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nweather <- read_csv(here(\"data\",\"weather.csv\"), col_types = cols(col_factor(), col_datetime(\"%Y%m%d%H\"), col_double()))\n```\n:::\n\n\n\n## Aufgabe 6\n\nErstelle nun eine *convenience* Variabel für die Kalenderwoche pro Messung (`lubridate::isoweek`). Berechne im Anschluss den mittleren Temperaturwert pro Kalenderwoche.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nweather_summary <- weather %>%\n  mutate(week = isoweek(time)) %>%\n  group_by(week) %>%\n  summarise(\n    temp_mean = mean(tre200h0, na.rm = TRUE)\n  )\n```\n:::\n\n\n\nVisualisiere im Anschluss das Resultat:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(weather_summary$week, weather_summary$temp_mean, type = \"l\")\n```\n\n::: {.cell-output-display}\n![](Prepro3_Uebung_files/figure-pdf/unnamed-chunk-8-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n## Aufgabe 7\n\nIn der vorherigen Aufgabe haben wir die mittlere Temperatur pro Kalenderwoche über *alle Jahre* (2000 und 2001) berechnet. Wenn wir die Jahre aber miteinander vergleichen wollen, müssen wir das Jahr als zusätzliche *convenience* Variabel erstellen und danach gruppieren. Versuche dies mit den Wetterdaten und visualisiere den Output anschliessend.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nweather_summary2 <- weather %>%\n  mutate(\n    week = week(time),\n    year = year(time)\n    ) %>%\n  group_by(year, week) %>%\n  summarise(\n    temp_mean = mean(tre200h0, na.rm = TRUE)\n  )\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n`summarise()` has grouped output by 'year'. You can override using the\n`.groups` argument.\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(weather_summary2$week, weather_summary2$temp_mean, type = \"l\")\n```\n\n::: {.cell-output-display}\n![baseplot mag keine long tables und macht aus den beiden Jahren eine kontinuierliche Linie](Prepro3_Uebung_files/figure-pdf/unnamed-chunk-10-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n## Aufgabe 8\n\nÜberführe den Output aus der letzten Übung in eine *wide table*. Nun lassen sich die beiden Jahre viel besser miteinander vergleichen.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nweather_summary2 <- weather_summary2 %>%\n  pivot_wider(names_from = year, values_from = temp_mean,names_prefix = \"year\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(weather_summary2$week, weather_summary2$year2000, type = \"l\",col = \"blue\")\nlines(weather_summary2$week, weather_summary2$year2001, type = \"l\",col = \"red\")\n```\n\n::: {.cell-output-display}\n![](Prepro3_Uebung_files/figure-pdf/unnamed-chunk-12-1.pdf){fig-pos='H'}\n:::\n:::\n",
    "supporting": [
      "Prepro3_Uebung_files\\figure-pdf"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {
      "knitr": [
        "{\"type\":\"list\",\"attributes\":{},\"value\":[]}"
      ]
    },
    "preserve": null,
    "postProcess": false
  }
}