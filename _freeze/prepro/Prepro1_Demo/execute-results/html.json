{
  "hash": "6259a4fdfc3e68cc047a56f2fad41e48",
  "result": {
    "markdown": "\n\n\n::: {.cell}\n\n:::\n\n\n\n\n\n# Prepro 1: Demo\n\n### Datentypen\n\n#### Numerics\n\nUnter die Kategorie `numeric` fallen in R zwei Datentypen:\n\n-   `double`: Gleitkommazahl (z.B. 10.3, 7.3)\n-   `integer`: Ganzzahl (z.B. 10, 7)\n\n##### Doubles\n\nFolgendermassen wird eine Gleitkommazahl einer Variabel zuweisen:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 10.3\n\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 10.3\n```\n:::\n\n```{.r .cell-code}\ntypeof(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"double\"\n```\n:::\n:::\n\n\nStatt `<-`kann auch `=` verwendet werden. Dies funktioniert aber nicht in allen Situationen, und ist zudem leicht mit `==` zu verwechseln.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ny = 7.3\n\ny\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 7.3\n```\n:::\n:::\n\n\nOhne explizite Zuweisung nimmt R immer den Datentyp `double`an:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nz <- 42\ntypeof(z)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"double\"\n```\n:::\n\n```{.r .cell-code}\nis.integer(z)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\nis.numeric(z)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\nis.double(z)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\n#### Ganzzahl / Integer\n\nErst wenn man eine Zahl explizit als `integer` definiert (mit `as.integer()` oder `L`), wird sie auch als solches abgespeichert.\n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- as.integer(z)\nis.numeric(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\nis.integer(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\nc <- 8L\nis.numeric(c)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\nis.integer(c)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"integer\"\n```\n:::\n\n```{.r .cell-code}\nis.numeric(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\nis.integer(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\nMit `c()` können eine Reihe von Werten in einer Variabel zugewiesen werden (als `vector`). Es gibt zudem auch `character vectors`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvector <- c(10,20,33,42,54,66,77)\nvector\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 10 20 33 42 54 66 77\n```\n:::\n\n```{.r .cell-code}\nvector[5]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 54\n```\n:::\n\n```{.r .cell-code}\nvector[2:4]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 20 33 42\n```\n:::\n\n```{.r .cell-code}\nvector2 <- vector[2:4]\n```\n:::\n\n\nEine Ganzzahl kann explizit mit `as.integer()` definiert werden.\n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- as.integer(7)\nb <- as.integer(3.14)\na\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 7\n```\n:::\n\n```{.r .cell-code}\nb\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n\n```{.r .cell-code}\ntypeof(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"integer\"\n```\n:::\n\n```{.r .cell-code}\ntypeof(b)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"integer\"\n```\n:::\n\n```{.r .cell-code}\nis.integer(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\nis.integer(b)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\nEine Zeichenkette kann als Zahl eingelesen werden.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc <- as.integer(\"3.14\")\nc\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n\n```{.r .cell-code}\ntypeof(c)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"integer\"\n```\n:::\n:::\n\n\n#### Logische Abfragen\n\nWird auch auch als boolesch (Eng. **boolean**) bezeichnet.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ne <- 3\nf <- 6\ng <- e > f\ne\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n\n```{.r .cell-code}\nf\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 6\n```\n:::\n\n```{.r .cell-code}\ng\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\ntypeof(g)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"logical\"\n```\n:::\n:::\n\n\n#### Logische Operationen\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsonnig <- TRUE\ntrocken <- FALSE\n\nsonnig & !trocken\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\nOft braucht man auch das Gegenteil / die Negation eines Wertes. Dies wird mittels `!` erreicht\n\n\n::: {.cell}\n\n```{.r .cell-code}\nu <- TRUE\nv <- !u \nv\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n:::\n\n\n#### Zeichenketten\n\nZeichenketten (Eng. **character**) stellen Text dar\n\n\n::: {.cell}\n\n```{.r .cell-code}\ns <- as.character(3.14)\ns\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"3.14\"\n```\n:::\n\n```{.r .cell-code}\ntypeof(s)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"character\"\n```\n:::\n:::\n\n\nZeichenketten verbinden / zusammenfügen (Eng. **concatenate**)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfname <- \"Hans\"\nlname <- \"Muster\"\npaste(fname,lname)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Hans Muster\"\n```\n:::\n\n```{.r .cell-code}\nfname2 <- \"hans\"\nfname == fname2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n:::\n\n\n#### `Factors`\n\nMit `Factors` wird in R eine Sammlung von Zeichenketten bezeichnet, die sich wiederholen, z.B. Wochentage (es gibt nur 7 unterschiedliche Werte für \"Wochentage\").\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwochentage <- c(\"Donnerstag\",\"Freitag\",\"Samstag\",\"Sonntag\",\"Montag\",\"Dienstag\",\"Mittwoch\",\n                \"Donnerstag\",\"Freitag\",\"Samstag\",\"Sonntag\", \"Montag\",\"Dienstag\",\"Mittwoch\")\n\ntypeof(wochentage)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"character\"\n```\n:::\n\n```{.r .cell-code}\nwochentage_fac <- as.factor(wochentage)\n\nwochentage\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"Donnerstag\" \"Freitag\"    \"Samstag\"    \"Sonntag\"    \"Montag\"    \n [6] \"Dienstag\"   \"Mittwoch\"   \"Donnerstag\" \"Freitag\"    \"Samstag\"   \n[11] \"Sonntag\"    \"Montag\"     \"Dienstag\"   \"Mittwoch\"  \n```\n:::\n\n```{.r .cell-code}\nwochentage_fac\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] Donnerstag Freitag    Samstag    Sonntag    Montag     Dienstag  \n [7] Mittwoch   Donnerstag Freitag    Samstag    Sonntag    Montag    \n[13] Dienstag   Mittwoch  \nLevels: Dienstag Donnerstag Freitag Mittwoch Montag Samstag Sonntag\n```\n:::\n:::\n\n\nWie man oben sieht, unterscheiden sich `character vectors` und `factors` v.a. dadurch, dass letztere über sogenannte `levels` verfügt. Diese `levels` entsprechen den Eindeutigen (`unique`) Werten.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlevels(wochentage_fac)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Dienstag\"   \"Donnerstag\" \"Freitag\"    \"Mittwoch\"   \"Montag\"    \n[6] \"Samstag\"    \"Sonntag\"   \n```\n:::\n\n```{.r .cell-code}\nunique(wochentage)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Donnerstag\" \"Freitag\"    \"Samstag\"    \"Sonntag\"    \"Montag\"    \n[6] \"Dienstag\"   \"Mittwoch\"  \n```\n:::\n:::\n\n\nZudem ist fällt auf, dass die Reihenfolge der Wohentag alphabetisch sortiert ist. Wie diese sortiert werden zeigen wir an einem anderen Beispiel:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nzahlen <- factor(c(\"null\",\"eins\",\"zwei\",\"drei\"))\n\nzahlen\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] null eins zwei drei\nLevels: drei eins null zwei\n```\n:::\n:::\n\n\nOffensichtlich sollten diese `factors` geordnet sein, R weiss davon aber nichts. Eine Ordnung kann man mit dem Befehl `ordered = T` festlegen.\n\nBeachtet: `ordered = T` kann nur bei der Funktion `factor()` spezifiziert werden, nicht bei `as.factor()`. Ansonsten sind `factor()` und `as.factor()` sehr ähnlich.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nzahlen <- factor(zahlen,ordered = TRUE)\n\nzahlen\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] null eins zwei drei\nLevels: drei < eins < null < zwei\n```\n:::\n:::\n\n\nBeachtet das \"\\<\"-Zeichen zwischen den Levels. Die Zahlen werden nicht in der korrekten Reihenfolge, sondern Alphabetisch geordnet. Die richtige Reihenfolge kann man mit `levels =` festlegen.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nzahlen <- factor(zahlen,ordered = T,levels = c(\"null\",\"eins\",\"zwei\",\"drei\",\"vier\"))\n\nzahlen\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] null eins zwei drei\nLevels: null < eins < zwei < drei < vier\n```\n:::\n:::\n\n\nWie auch schon erwähnt werden `factors` als `character` Vektor dargestellt, aber als Integers gespeichert. Das führt zu einem scheinbaren Wiederspruch wenn man den Datentyp auf unterschiedliche Weise abfragt.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(zahlen)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"integer\"\n```\n:::\n\n```{.r .cell-code}\nis.integer(zahlen)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n:::\n\n\nMit `typeof()` wird eben diese Form der Speicherung abgefragt und deshalb mit `integer` beantwortet. Da es sich aber nicht um einen eigentlichen Integer Vektor handelt, wird die Frage `is.integer()` mit `FALSE` beantwortet. Das ist etwas verwirrend, beruht aber darauf, dass die beiden Funktionen die Frage von unterschiedlichen Perspektiven beantworten. In diesem Fall schafft `class()` Klarheit:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(zahlen)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"ordered\" \"factor\" \n```\n:::\n:::\n\n\nWirklich verwirrend wird es, wenn `factors` in numeric umgewandelt werden sollen.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nzahlen\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] null eins zwei drei\nLevels: null < eins < zwei < drei < vier\n```\n:::\n\n```{.r .cell-code}\nas.integer(zahlen)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3 4\n```\n:::\n:::\n\n\nDas die Übersetzung der auf Deutsch ausgeschriebenen Nummern in nummerische Zahlen nicht funktionieren würde, war ja klar. Weniger klar ist es jedoch, wenn die `factors` bereits aus nummerischen Zahlen bestehen.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nzahlen2 <- factor(c(\"10\",\"20\"))\nas.integer(zahlen2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2\n```\n:::\n:::\n\n\nIn diesem Fall müssen die `factors` erstmals in `character` umgewandelt werden.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nas.integer(as.character(zahlen2))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 10 20\n```\n:::\n:::\n\n\n#### Zeit/Datum\n\nUm in R mit Datum/Zeit Datentypen umzugehen, müssen sie als `POSIXct` eingelesen werden (es gibt alternativ noch `POSIXlt`, aber diese ignorieren wir mal). Anders als Beispielsweise bei Excel, sollten in R Datum und Uhrzeit immer in **einer Spalte** gespeichert werden.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndatum <- \"2017-10-01 13:45:10\"\n\nas.POSIXct(datum)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2017-10-01 13:45:10 UTC\"\n```\n:::\n:::\n\n\nWenn das die Zeichenkette in dem obigen Format (Jahr-Monat-Tag Stunde:Minute:Sekunde) daher kommt, braucht `as.POSIXct`keine weiteren Informationen. Sollte das Format von dem aber Abweichen, muss man der Funktion das genaue Schema jedoch mitteilen. Der Syntax dafür kann via `?strptime` nachgeschlagen werden.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndatum <- \"01.10.2017 13:45\"\n\nas.POSIXct(datum,format = \"%d.%m.%Y %H:%M\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2017-10-01 13:45:00 UTC\"\n```\n:::\n\n```{.r .cell-code}\ndatum <- as.POSIXct(datum,format = \"%d.%m.%Y %H:%M\")\n```\n:::\n\n\nBeachtet, dass in den den obigen Beispiel R automatisch eine Zeitzone angenommen hat (`CEST`). R geht davon aus, dass die Zeitzone der **System Timezone** (`Sys.timezone()`) entspricht.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstrftime(datum, format = \"%m\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"10\"\n```\n:::\n\n```{.r .cell-code}\nstrftime(datum, format = \"%b\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Oct\"\n```\n:::\n\n```{.r .cell-code}\nstrftime(datum, format = \"%B\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"October\"\n```\n:::\n:::\n\n\n### Data Frames und Conveniance Variabeln\n\nEine `data.frame` ist die gängigste Art, Tabellarische Daten zu speichern.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- data.frame(\n  Stadt = c(\"Zürich\",\"Genf\",\"Basel\",\"Bern\",\"Lausanne\"),\n  Einwohner = c(396027,194565,175131,140634,135629),\n  Ankunft = c(\"1.1.2017 10:00\",\"1.1.2017 14:00\",\n              \"1.1.2017 13:00\",\"1.1.2017 18:00\",\"1.1.2017 21:00\")\n)\n\nstr(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n'data.frame':\t5 obs. of  3 variables:\n $ Stadt    : chr  \"Zürich\" \"Genf\" \"Basel\" \"Bern\" ...\n $ Einwohner: num  396027 194565 175131 140634 135629\n $ Ankunft  : chr  \"1.1.2017 10:00\" \"1.1.2017 14:00\" \"1.1.2017 13:00\" \"1.1.2017 18:00\" ...\n```\n:::\n:::\n\n\nIn der obigen `data.frame` wurde die Spalte `Einwohner` als Fliesskommazahl abgespeichert. Dies ist zwar nicht tragisch, aber da wir wissen das es sich hier sicher um Ganzzahlen handelt, können wir das korrigieren. Wichtiger ist aber, dass wir die Ankunftszeit (Spalte`Ankunft`) von einem `Factor` in ein Zeitformat (`POSIXct`) umwandeln.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf$Einwohner <- as.integer(df$Einwohner)\n\ndf$Einwohner\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 396027 194565 175131 140634 135629\n```\n:::\n\n```{.r .cell-code}\ndf$Ankunft <- as.POSIXct(df$Ankunft, format = \"%d.%m.%Y %H:%M\")\n\ndf$Ankunft\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2017-01-01 10:00:00 UTC\" \"2017-01-01 14:00:00 UTC\"\n[3] \"2017-01-01 13:00:00 UTC\" \"2017-01-01 18:00:00 UTC\"\n[5] \"2017-01-01 21:00:00 UTC\"\n```\n:::\n:::\n\n\nDiese Rohdaten können nun helfen, um Hilfsvariablen (**convenience variables**) zu erstellen. Z.B. können wir die Städte einteilen in gross, mittel und klein.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf$Groesse[df$Einwohner > 300000] <- \"gross\"\ndf$Groesse[df$Einwohner <= 300000 & df$Einwohner > 150000] <- \"mittel\"\ndf$Groesse[df$Einwohner <= 150000] <- \"klein\"\n```\n:::\n\n\nOder aber, die Ankunftszeit kann von der Spalte `Ankunft`abgeleitet werden. Dazu brauchen wir aber das Package `lubridate`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(lubridate)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndf$Ankunft_stunde <- hour(df$Ankunft)\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}