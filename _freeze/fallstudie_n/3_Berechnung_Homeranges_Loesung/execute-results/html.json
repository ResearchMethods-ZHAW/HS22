{
  "hash": "9c9d068658a8a5dc7737cafa9a2809aa",
  "result": {
    "markdown": "# 3. Lösung\n\n\n\n\n\n## Berechung der Home-Ranges der Rehe \n\n### Libraries laden\n\n\n::: {.cell}\n\n```{.r .cell-code}\nipak <- function(pkg) {\n    new.pkg <- pkg[!(pkg %in% installed.packages()[, \"Package\"])]\n    if (length(new.pkg))\n        install.packages(new.pkg, repos = \"http://cran.us.r-project.org\",\n            dependencies = TRUE)\n    sapply(pkg, require, character.only = TRUE)\n}\npackages <- c(\"sf\", \"raster\", \"tidyverse\", \"adehabitatHR\", \"maptools\",\n    \"sp\", \"ggspatial\", \"rgeos\", \"rgdal\", \"pastecs\")\nipak(packages)\n```\n:::\n\n\n### Daten einlesen\n\nEinlesen des Gesamtdatensatzes von Moodle, Sichtung des Datensatzes und der Datentypen\n\n\n::: {.cell}\n\n```{.r .cell-code}\nRehe <- read_delim(\"data/Aufgabe3_Homeranges_Rehe_landforst_20211014.csv\",\n    delim = \";\")\n\nstr(Rehe)\n```\n:::\n\n\n### Aufgabe 1\n\nIn Datensatz Rehe eine neue Spalte mit Datum und Zeit in einer Spalte kreieren. Beim Format hat sich ein Fehler eingeschlichen. Findet ihr ihn?\n\n\n::: {.cell warnings='false'}\n\n```{.r .cell-code}\nRehe <- Rehe %>%\n    mutate(UTC_DateTime = as.POSIXct(paste(UTC_Date, UTC_Time),\n        format = \"%Y-%m-%d %H:%M:%S\"))\n```\n:::\n\n\nHier einige Zeilen Code, um eine HomeRange zu berechnen.\n\n### Aufgabe 2\n\nHerumschrauben an den Einstellungen von: \n\n- href (in der Funktion kernelUD)\n- an der Ausdehung, resp. prozentualer Anteil Punkte in der HR (Funktion getverticeshr) \n--> Ziel: eine Karte erstellen mit der Visualiserung mindestens einer HR\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- Rehe$X[Rehe$TierID == \"RE13\"]\ny <- Rehe$Y[Rehe$TierID == \"RE13\"]\nxy <- data.frame(cbind(x, y, rep(1, length(x))))\ncoordinates(xy) <- c(\"x\", \"y\")\nproj4string(xy) <- CRS(\"+init=epsg:21781\")\n\nplot(xy, col = \"blue\", pch = 19, cex = 1.5)\n\n# Berechnung von href nach: Pebsworth et al. (2012)\n# Evaluating home range techniques: use of Global\n# Positioning System (GPS) collar data from chacma baboons\n\nsigma <- 0.5 * (sd(x) + sd(y))\nn <- length(x)\nhref <- sigma * n^(-1/6) * 0.9\n\n# scaled reference: href * 0.9\n\nkud <- kernelUD(xy, h = href, grid = 25)\n\n# Berechnung der Home Range (95% Isopleth)\n\nhomerange <- getverticeshr(kud, percent = 50)\n\n# Schreibt HR in den oben beschriebenen Ordner (als\n# Shapefile)\n\nhr <- st_as_sf(homerange)\n\nst_write(hr, dsn = \"data/Results\", layer = \"HR_RE13\", driver = \"ESRI Shapefile\",\n    delete_layer = TRUE)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# mit diesem Befehl kann die HR geplottet werden\n\nggplot(hr, aes(color = \"red\", fill = \"red\")) + geom_sf(size = 1,\n    alpha = 0.3) + coord_sf(datum = sf::st_crs(21781)) + theme(axis.title = element_blank(),\n    axis.text = element_blank(), axis.ticks = element_blank(),\n    legend.position = \"none\")\n\n# und die Punkte der GPS-Lokalisationen darüber gelegt\n# werden\n\nxy_p <- st_as_sf(xy)\n\nggplot(hr, aes(color = \"red\", fill = \"red\")) + geom_sf(size = 1,\n    alpha = 0.3) + geom_sf(data = xy_p, aes(fill = \"red\")) +\n    coord_sf(datum = sf::st_crs(21781)) + theme(axis.title = element_blank(),\n    axis.text = element_blank(), axis.ticks = element_blank(),\n    legend.position = \"none\")\n```\n:::\n\n\nCode um die Homerange auf der Landeskarte 1:25000 zu plotten. Transparenz kann mit alpha angepasst werden\n\n\n::: {.cell}\n\n```{.r .cell-code}\npk25_wpz <- brick(\"data/pk25_wpz.tif\")\n\nxy_p <- st_as_sf(xy)\n\nggplot(hr, aes(color = \"red\", fill = \"red\")) + annotation_spatial(pk25_wpz) +\n    geom_sf(size = 1, alpha = 0.3) + geom_sf(data = xy_p, aes(fill = \"red\")) +\n    coord_sf(datum = sf::st_crs(21781)) + theme(axis.title = element_blank(),\n    axis.text = element_blank(), axis.ticks = element_blank(),\n    legend.position = \"none\")\n```\n\n::: {.cell-output-display}\n![](3_Berechnung_Homeranges_Loesung_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n\nNachbauen des Sampling Grids mit den Kreisen (Wird als Grundlage für Extraktion der Umweltvariablen innerhalb der Homeranges benötigt)\n\n- Xmin bzw. Ymin des Grids: c(684000, 234000)\n- cellsize des Grids: c(25, 25)\n- Anzahl Kreise in X und Y Richtung: c(100, 160)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx25 <- GridTopology(c(684000, 234000), c(25, 25), c(100, 160))\ndata25 = data.frame(1:(100 * 160))\n# Erstellt aus der GridTopology und den Daten ein\n# SpatialGridDataFrame\ngrid25 <- SpatialGridDataFrame(x25, data25, proj4string <- CRS(\"+init=epsg:21781\"))\npixel25 <- as(grid25, \"SpatialPixelsDataFrame\")\n\n# zweites Sampling Grid für einen Ausschnitt aufbauen,\n# plotten -> dient nur der Visualisierung des Sampling\n# Grids um einen Eindruck zu erhalten\n\nx <- GridTopology(c(684200, 236900), c(25, 25), c(35, 35))\ndata = data.frame(1:(35 * 35))\n# Erstellt aus der GridTopology und den Daten ein\n# SpatialGridDataFrame\ngrid <- SpatialGridDataFrame(x, data, proj4string <- CRS(\"+init=epsg:21781\"))\npixel <- as(grid, \"SpatialPixelsDataFrame\")\n\npoints <- as(pixel, \"SpatialPointsDataFrame\")\n\ngrid_plot <- st_buffer(st_as_sf(points), 12.5)\n\nplot(st_geometry(grid_plot))\n\nggplot(grid_plot, color = \"black\", fill = NA) + geom_sf() + geom_sf(data = xy_p,\n    color = \"blue\", ) + geom_sf(data = hr, color = \"red\", fill = NA,\n    size = 2) + coord_sf(datum = sf::st_crs(21781)) + theme(axis.title = element_blank(),\n    axis.text = element_blank(), axis.ticks = element_blank(),\n    legend.position = \"none\")\n```\n:::\n\n\n### Aufgabe 3\n\nTesten der Variablen der Vegetationsschichten von letzter Woche auf einen linearen Zusammenhang (Korrelation; Funktion cor.test). DG_Baumschicht vs. DG_os / DG_Strauchschicht vs. DG_us aus dem Datensatz df_with_lidar den wir letzte Woche erstellt haben\n\nDie Theorie zu Korrelation folgt erst ab 1.11\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_with_lidar <- read_delim(\"data/df_with_lidar.csv\", delim = \";\")\n\nlibrary(pastecs)\n\nround(stat.desc(cbind(df_with_lidar$DG_us, df_with_lidar$DG_os,\n    df_with_lidar$DG_Strauchschicht, df_with_lidar$DG_Baumschicht),\n    basic = F, norm = T), 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                 V1     V2      V3      V4\nmedian        0.272  0.824  35.000  50.000\nmean          0.295  0.788  38.949  50.273\nSE.mean       0.013  0.013   1.926   1.782\nCI.mean.0.95  0.027  0.026   3.806   3.522\nvar           0.027  0.025 556.585 476.549\nstd.dev       0.164  0.159  23.592  21.830\ncoef.var      0.557  0.201   0.606   0.434\nskewness      0.661 -1.034   0.438   0.042\nskew.2SE      1.662 -2.601   1.106   0.105\nkurtosis     -0.068  0.670  -0.834  -0.930\nkurt.2SE     -0.087  0.848  -1.059  -1.182\nnormtest.W    0.959  0.910   0.953   0.974\nnormtest.p    0.000  0.000   0.000   0.007\n```\n:::\n\n```{.r .cell-code}\n# Histogram der Verteilung und die aus den Daten berechnete\n# Normalverteilung als Linie dargestellt\n\nggplot(df_with_lidar, aes(DG_os)) + geom_histogram(aes(y = ..density..),\n    color = \"black\", fill = \"white\") + stat_function(fun = dnorm,\n    args = list(mean = mean(df_with_lidar$DG_os, na.rm = T),\n        sd = sd(df_with_lidar$DG_os, na.rm = T)), color = \"black\",\n    size = 1)\n```\n\n::: {.cell-output-display}\n![](3_Berechnung_Homeranges_Loesung_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n\n```{.r .cell-code}\n# testen auf Korrelation\n\ncor.test(~DG_Baumschicht + DG_os, data = df_with_lidar, method = \"pearson\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n\tPearson's product-moment correlation\n\ndata:  DG_Baumschicht and DG_os\nt = 5.4918, df = 147, p-value = 1.705e-07\nalternative hypothesis: true correlation is not equal to 0\n95 percent confidence interval:\n 0.2696941 0.5377248\nsample estimates:\n      cor \n0.4126009 \n```\n:::\n:::\n",
    "supporting": [
      "3_Berechnung_Homeranges_Loesung_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}