{
  "hash": "7128d79658ba773b45e2063d439c7c1f",
  "result": {
    "markdown": "---\ndate: 2022-12-05\nlesson: RaumAn3\nthema: Morans I\nindex: 1\nexecute: \n  echo: false\n  include: true\n  eval: false\n---\n\n\n# Rauman 3: Übung\n\n\nHeute berechnen wir Morans $I$, also ein globales Mass für Autokorrelation, für die Abstimmungsresultate der Zweitwohnungsinitiative. Dieser berechnete Wert beschreibt, ob Kantone, die nahe beieinander liegen ähnliche Abstimmungswerte haben. Hierfür verwenden wir folgenden Datensatz:\n\n\n- [zweitwohnungsinitiative.gpkg](https://moodle.zhaw.ch/mod/resource/view.php?id=602283)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\nlibrary(ggplot2)\nlibrary(sf)\n\n# Das Geopackage beinhaltet 3 Layers (siehe st_layers(\"zweitwohnungsinitiative.gpkg\"))\n# In jedem Layer sind die Abstimmungsresultate auf eine andere politische Ebene\n# aggregiert. Wir started mit der Aggregationsstufe \"kanton\"\nzweitwohnung_kanton <- read_sf(\"datasets/rauman/zweitwohnungsinitiative.gpkg\", \"kanton\")\n```\n:::\n\n::: {.cell}\n\n:::\n\n\n\nFür die Berechnung von Morans $I$ benutzen wir kein externes Package, sondern erarbeiten uns alles selber, basierend auf der Formel von Moran's $I$: \n\n\n$$I = \\frac{n}{\\sum_{i=1}^n (y_i - \\bar{y})^2} \\times \\frac{\\sum_{i=1}^n \\sum_{j=1}^n w_{ij}(y_i - \\bar{y})(y_j - \\bar{y})}{\\sum_{i=1}^n \\sum_{j=1}^n w_{ij}}$$\n\n\n\nwobei:\n\n- $n$ der Anzahl räumlichen Objekte (hier: Kantone) in unserem Datensatz entspricht\n- $y$ der untersuchten Variabel entspricht (hier: Ja-Anteil in %)\n- $\\bar{y}$ dem Mittelwert der untersuchten Variabel entspricht\n- $w_{ij}$ der Gewichtsmatrix entspricht\n\n\n\n$$I =\\frac{\\text{z1}}{\\text{n1}}\\times\\frac{\\text{z2}}{\\text{n2}}$$\n\n\n\nDiese sieht sehr beeindruckend aus, aber wenn wir die Formel in ihre Einzelbestandteile aufteilen, sehen wir, dass diese in sich gar nicht so komplex sind. So teilen wir ein vermeintlich komplexes Problem in überschaubare Einzelteile. Dieses Vorgehen illustriert ausserdem sehr schön ein generelles Data Science Prinzip. Divide and Conquer - Teile und Herrsche: Teile ein komplexes Problem in kleinere, beherrschbare Unterprobleme. \n\n## Aufgabe 1: Morans $I$ für Kantone\n\n\n### Berechnung von $n$\n\n\n$$I = \\frac{\\color{red}n}{\\sum_{i=1}^{\\color{red}n} (y_i - \\bar{y})^2} \\times \\frac{\\sum_{i=1}^n \\sum_{j=1}^{\\color{red}n}  w_{ij}(y_i - \\bar{y})(y_j - \\bar{y})}{\\sum_{i=1}^n \\sum_{j=1}^{\\color{red}n}  w_{ij}}$$\n\n\n\nBeginnen wir mit der Variabel $n$. Dies ist lediglich die Anzahl Messwerte in unserem Datensatz, also die Anzahl Kantone. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nn <- nrow(zweitwohnung_kanton)\nn\n```\n:::\n\n\n### Abweichung vom Mittelwert \n\n\n$$I = \\frac{n}{\\color{red}\\sum_{i=1}^n (y_i - \\bar{y})^2} \\times \\frac{{\\color{orange}\\sum_{i=1}^n} \\sum_{j=1}^n w_{ij}{\\color{orange}(y_i - \\bar{y})(y_j - \\bar{y})}}{\\sum_{i=1}^n \\sum_{j=1}^n w_{ij}}$$\n\n\n\nDer Nenner des ersten Bruches entspricht fast der Berechnung der Varianz. Wir berechnen für jeden Messwert die Differenz zum Durchschnitt ($y_i - \\bar{y}$), quadrieren diese einzelwerte und nehmen davon die Summe. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Die Werte aller Kantone in einer Variabel abspeichern\ny <- zweitwohnung_kanton$ja_in_percent\n\n# Der Durchschnittswert aller Kantone berechnen\nybar <- mean(y, na.rm = TRUE)\n\n# Von jedem Wert den Durchschnittswert abziehen:\ndy <- y - ybar\n\n# Die Differenzen quadrieren\ndy_2 <- dy^2\n\n# Und davon die Summe bilden:\ndy_sum <- sum(dy_2, na.rm = TRUE)\n```\n:::\n\n\n\n<!--\n#### Auflösung (Bruch 1)\n\nBeschliessen wir die Bearbeitung des ersten Bruchs indem wir den Zähler durch den Nennen dividieren:  `n` durch `dy_sum`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvr <- n/dy_sum\n```\n:::\n\n\n-->\n\n<!--\n### Bruch 2\n\n\n\nHier berechnen wir die Summe aller Gewichte sowie die gewichteten Covarianzen. Wir betrachten immer Messwertpaare, sprich paarweise Vergleiche zweier Raumeinheiten (hier Kantone). Deshalb haben die zwei Summenzeichen die beiden unterschiedlichen Laufvariablen ($i$ und $j$). Solche paarweise Vergleiche von Werten mit allen anderen Werten können wir elegant mit Kreuzmatrizen abbilden. In der Kreuzmatrix vergleichen wir jeden Messwert mit allen anderen Messwerten. Dabei gibt es zwei Kreuzmatrizen: ($w_{ij}$ ist die erste Kreuzmatrix, $(y_i - \\bar{y})(y_j - \\bar{y})$ ist die zweite Kreuzmatrix). \n\n-->\n\n### Kreuzmatrix\n\n\n$$I = \\frac{n}{\\sum_{i=1}^n (y_i - \\bar{y})^2} \\times \\frac{{\\color{red}\\sum_{i=1}^n \\sum_{j=1}^n} w_{ij}(y_i - \\bar{y})(y_j - \\bar{y})}{{\\color{red}\\sum_{i=1}^n \\sum_{j=1}^n}^n w_{ij}}$$\n\n\n\nWährend das alleinstehende Summenzeichen ($\\sum$) noch einigermassen nachvollziehbar ist, sind die doppelten Summenzeichen etwas verwirrlich und braucht etwas Erklärung. $\\sum_{i=1}^n \\sum_{j=1}^n$ stellt eine Kreuzmatrix dar, in dem jeder Wert mit jedem anderen Wert verglichen wird. Also das Abstimmungsresultat des Kantons Zürich wird mit allen anderen 25 Kantonen verglichen, das gleiche gilt für den Kanton Bern, Basel usw. Die nachfolgenden Berechnungen müssen wir also in dieser Kreuzmatrix durchführen. \n\n### Räumliche Gewichtung\n\n\n$$I = \\frac{n}{\\sum_{i=1}^n (y_i - \\bar{y})^2} \\times \\frac{\\sum_{i=1}^n \\sum_{j=1}^n {\\color{red}w_{ij}}(y_i - \\bar{y})(y_j - \\bar{y})}{\\sum_{i=1}^n \\sum_{j=1}^n {\\color{red}w_{ij}}}$$\n\n\n\n$w_{ij}$, beschreibt die räumlichen Gewichte aller Kantone. Sind die Kantone räumlich nah, dann gilt ein Gewicht von 1, sind sie räumlich weit entfernt, gilt ein Gewicht von 0. Dies entspricht dem \"Schalter\" aus der Vorlesung. Dabei ist die Definition von \"räumlich nah\" nicht festgelegt. Denkbar wären zum Beispiel folgende Optionen:\n\n- Die Kantone müssen sich berühren: `st_touches()`\n- Die Kantone müssen innerhalb einer bestimmten Distanz zueinander liegen: `st_is_within_distance()`\n\nEgal für welche Variante Ihr Euch entscheidet, setzt `sparse = FALSE` damit eine Kreuzmatrix erstellt wird. (Lasst Euch nicht davon beirren, dass wir nun `TRUE` und `FALSE` statt `1` und `0` haben. In R sind `TRUE` und `1` äquivalent, sowie auch `FALSE` und `0`). \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# st_touches berechnet eine Kreuzmatrix aller Objekte\nw <- st_touches(zweitwohnung_kanton, sparse = FALSE)\n\n# Schauen wir uns die ersten 5 Reihen und Zeilen an\nw[1:5, 1:5]\n```\n:::\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n:::\n\n\n\nZur Überprüfung unserer Operation: Mit `w[1,]` bekommt  ihr ein Vektor, wo bei allen Kantone, die den ersten kanton () berühren `TRUE` steht und bei allen anderen `FALSE`. Nun können wir überprüfen, ob die räumliche Operation funktioniert hat. Könnt ihr die nachfolgende Visualisierung rekonstruieren?\n\n\n::: {.cell}\n\n:::\n\n\n\n### Abweichung vom Mittelwert\n\n\n$$I = \\frac{n}{\\sum_{i=1}^n (y_i - \\bar{y})^2} \\times \\frac{\\sum_{i=1}^n \\sum_{j=1}^n w_{ij}{\\color{red}(y_i - \\bar{y})(y_j - \\bar{y})}}{\\sum_{i=1}^n \\sum_{j=1}^n w_{ij}}$$\n\n\nDie Abweichung vom Mittelwert haben wir ja bereits gerechnet und in der Variabel `dy` abgespeichert. Nun gilt es paarweise das Produkt der Abweichungen vom Mittelwert (die Covarianz) zu berechnen $(y_i - \\bar{y})(y_j - \\bar{y})$.  Dazu müssen wir *das Produkt aller Wertekombinationen* berechnen. Dies erreichen wir mit der Funktion `tcrossprod()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# berechnet das Proukt aller Wertekombinationen\npm <- tcrossprod(dy)\n\n# die ersten für Reihen und Spalten des Resultas\npm[1:5,1:5]\n```\n:::\n\n\n\n<!--\nNun multiplizieren wir die Covarianzen mit den Gewichten $w$ (Schalter), damit wir nur noch die Werte von den Kantonen haben, die auch effektiv benachbart sind (und eliminieren nicht-benachbarte Werte). Beachtet dass wir hier nun eine Matrix mit einer Matrix multiplizieren.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npmw <- pm * w\nw[1:5,1:5]\npmw[1:5,1:5]\n```\n:::\n\n\nDen Zähler des ersten Bruches können wir nun fertig berechnen, indem wir die Summe aller gewichten (sprich eingeschalteten) Werten bilden:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nspmw <- sum(pmw, na.rm = TRUE)\nspmw\n```\n:::\n\n\n\n#### Nenner (Bruch 2)\n\nFür den Nenner des zweiten Teils der Formal (des zweiten Bruchs) müssen wir nun nur noch alle Gewichte summieren. Diese Summer entspricht der Anzahl effektiv benachbarter Kantone und kann Anzahl der `TRUE`-Werte in $w$ bestimmt werden. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nsmw <- sum(w, na.rm = TRUE)\n```\n:::\n\n\n#### Auflösung (Bruch 2)\n\nSo können wir den zweiten Bruch auflösen und berechnen:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsw  <- spmw / smw\n```\n:::\n\n\n### Auflösung der Formel\n\nDer allerletzte Schritt besteht darin, die Werte aus den beiden Brüche miteinander zu multiplizieren.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nMI <- vr * sw\nMI\n```\n:::\n\n\n-->\nDer Global Morans $I$ für die Abstimmungsdaten beträgt auf Kantonsebene also . Wie interpretiert ihr dieses Resultate? Was erwartet ihr für eine Resultat auf Gemeinde- oder Bezirksebene?\n\n## Aufgabe 2: Morans I für Gemeinde oder Bezirke berechnen\n\nNun könnt ihr Morans $I$ auf der Ebene der Gemeine oder Bezirke und untersuchen, ob und wie sich Morans $I$ verändert. Wenn ihr einen wenig leistungsfähigen Rechner habt, berechnet verwendet besser die Ebene \"Berzirke\". Importiert dazu den Layer `berirk` oder `gemeinde` aus dem Datensatz `zweitwohnungsinitiative.gpkg`. Visualisiert in einem ersten Schritt die Abstimmungsresultate. Tipp: wir verwenden das Package `cowplot` um zwei `ggplots` nebeneinander darzustellen.\n\nNach der Brechnung von Morans $I$ könnt ihr die Werte auf der Ebene Gemeinde (bzw. Bezirke) und Kantone vergleichen. Formuliert zuerste eine Erwartungshaltung: ist Morans $I$ auf der Ebene Gemeinde (bzw. Bezirke) tiefer oder Höher als auf der Ebene Kantone?\n\n:::{.callout-note}\n## Für Fortgeschrittene \n\nErstellt aus dem erarbeiten Workflow eine *function* um Morans I auf der Basis von einem `sf` Objekt sowie einer Spalte dessen zu berechnen. \n:::\n\n\n::: {.cell .column-page layout-ncol=\"2\"}\n\n:::\n\n::: {.cell .column-page}\n\n:::\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n:::",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}