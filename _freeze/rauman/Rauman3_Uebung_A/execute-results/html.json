{
  "hash": "892646df844a59db1a210fe3924792e7",
  "result": {
    "markdown": "---\ndate: 2022-12-05\nlesson: RaumAn3\nthema: Morans I\nindex: 1\n---\n\n\n# Rauman 3: Übung\n\n  <!-- # Zum Abschluss des Themenblockes Spatial Data Science berechnen wir mit dem Moran’s I einen Index zur Berechnung der räumlichen Autokorrelation einer Choroplethenkarte. Wir verwenden nochmals die aggregierten Choroplethenkarten zur Wasserverfügbarkeit aus der ersten Übung und schauen uns an, wie stark die Werte für die Kantone und die Kantone autokorreliert sind. Anstatt einfach eine Funktion zur Berechnung von Moran’s I aufzurufen und diese dann wie eine Black Box anzuwenden, wollen wir Formel für die Berechnung des Index in Ihre Bausteine zerlegen und diese Schritt für Schritt selber nachrechnen. So seht Ihr, wie  Moran’s I wirklich funktioniert und könnte dabei erst noch die zuvor gelernten Data Science Techniken repetieren.  -->\n\n\n\n\n\nFür die Berechnung von Morans $I$ benutzen wir kein externes Package, sondern erarbeiten uns alles selber, basierend auf der Formel von Moran's $I$: \n\n\n$$I = \\frac{n}{\\sum_{i=1}^n (y_i - \\bar{y})^2} \\times \\frac{\\sum_{i=1}^n \\sum_{j=1}^n w_{ij}(y_i - \\bar{y})(y_j - \\bar{y})}{\\sum_{i=1}^n \\sum_{j=1}^n w_{ij}}$$\n\nDiese sieht sehr beeindruckend aus, aber wenn wir die Formel in ihre Einzelbestandteile aufteilen, sehen wir, dass diese in sich gar nicht so komplex sind.\n\nAls erster Schritt müssen wir die notwendigen Libraries und Geodaten laden:\n\n- Datensatz: [zweitwohnungsinitiative.gpkg](https://moodle.zhaw.ch/mod/resource/view.php?id=602283)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\nlibrary(ggplot2)\nlibrary(sf)\n\n# Das Geopackage beinhaltet 3 Layers (siehe st_layers(\"zweitwohnungsinitiative.gpkg\"))\n# In jedem Layer sind die Abstimmungsresultate auf eine andere politische Ebene\n# aggregiert. Wir started mit der Aggregationsstufe \"kanton\"\nzweitwohnung_kanton <- read_sf(\"datasets/rauman/zweitwohnungsinitiative.gpkg\", \"kanton\")\n```\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![](Rauman3_Uebung_A_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n:::\n\n\n## Aufgabe 1: Herleitung der Formel\n\nIn der ersten Übung wollen wir Moran's $I$ für eine gegebene Choroplethenkarte nachrechnen. Dazu nehmen wir die Formel für Moran's $I$ und zerlegen sie in Einzelteile, die wir dann Schritt für Schritt für unsere Daten berechnen. So teilen wir ein vermeintlich komplexes Problem in überschaubare Einzelteile. Dieses Vorgehen illustriert ausserdem sehr schön ein generelles Data Science Prinzip. Divide and Conquer - Teile und Herrsche: Teile ein komplexes Problem in kleinere, beherrschbare Unterprobleme. Wir beginnen mit dem ersten Bruch und berechnen dabei zuerst den Zähler, dann dem Nenner. So können wir den Bruch auflösen und uns danach dem zweiten Bruch zuwenden:\n\n\n$$I = \\frac{n}{\\sum_{i=1}^n (y_i - \\bar{y})^2} \\times \\frac{\\sum_{i=1}^n \\sum_{j=1}^n w_{ij}(y_i - \\bar{y})(y_j - \\bar{y})}{\\sum_{i=1}^n \\sum_{j=1}^n w_{ij}}$$\n\n### Bruch 1\n\nWidmen wir uns dem ersten Bruch:\n\n\n$$\\frac{n}{\\sum_{i=1}^n (y_i - \\bar{y})^2}$$ \n\n\n#### Zähler (von Bruch 1)\n\nBeginnen wir mit dem Zähler, $n$. Dies ist lediglich die Anzahl Messwerte in unserem Datensatz, also die Anzahl Kantone. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nn <- nrow(zweitwohnung_kanton)\nn\n## [1] 26\n```\n:::\n\n\n#### Nenner (von Bruch 1)\n\nDer Nenner des ersten Bruches (${\\sum_{i=1}^n (y_i - \\bar{y})^2}$) ist sehr ähnlich der Berechnung der Varianz:\n\n1. Berechne den Durchschnitt aller Messwerte ($\\bar{y}$)\n2. Berechne für jeden Messwert die Differenz zum Durchschnitt ($y_i - \\bar{y}$)\n3. Quadriere diese Werte $(y_i - \\bar{y})^2$\n4. Summiere die Quadrierten Werte $\\sum_{i=1}^n$\n\nAlso berechnen wir zuerst diese Differenzwerte (Messwert minus Mittelwert):\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Die Werte aller Kantone:\ny <- zweitwohnung_kanton$ja_in_percent\n\n# Der Durchschnittswert aller Kantone\nybar <- mean(y, na.rm = TRUE)\n\n# von jedem Wert den Durchschnittswert abziehen:\ndy <- y - ybar\n```\n:::\n\n\nWelche dieser Zwischenresultate sind Einzelwerte und welche Vektoren? Nun quadrieren wir die Differenzen:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndy_2 <- dy^2\n```\n:::\n\n\nund summieren die Differenzen:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndy_sum <- sum(dy_2, na.rm = TRUE)\n```\n:::\n\n\n#### Auflösung (Bruch 1)\n\nBeschliessen wir die Bearbeitung des ersten Bruchs indem wir den Zähler durch den Nennen dividieren:  `n` durch `dy_sum`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvr <- n/dy_sum\n```\n:::\n\n\n### Bruch 2\n\nWenden wir uns nun also dem Bruches der Formel zu. \n\n\n$$\\frac{\\sum_{i=1}^n \\sum_{j=1}^n w_{ij}(y_i - \\bar{y})(y_j - \\bar{y})}{\\sum_{i=1}^n \\sum_{j=1}^n w_{ij}}$$\n\n\nHier berechnen wir die Summe aller Gewichte sowie die gewichteten Covarianzen. Wir betrachten immer Messwertpaare, sprich paarweise Vergleiche zweier Raumeinheiten (hier Kantone). Deshalb haben die zwei Summenzeichen die beiden unterschiedlichen Laufvariablen ($i$ und $j$). Solche paarweise Vergleiche von Werten mit allen anderen Werten können wir elegant mit Kreuzmatrizen abbilden. In der Kreuzmatrix vergleichen wir jeden Messwert mit allen anderen Messwerten. Dabei gibt es zwei Kreuzmatrizen: ($w_{ij}$ ist die erste Kreuzmatrix, $(y_i - \\bar{y})(y_j - \\bar{y})$ ist die zweite Kreuzmatrix). \n\n#### Zähler (Bruch 2)\n\nDer erste Term, $w_{ij}$, beschreibt die räumlichen Gewichte aller Kantone. Sind die Kantone benachbart, dann gilt ein Gewicht von 1,  sind sie nicht benachbart, gilt ein Gewicht von 0. Dies entspricht dem Schalter aus der Vorlesung.\n\nWie wir \"benachbart\" definieren ist nicht festgelegt. Denkbar wären zum Beispiel folgende Optionen:\n\n- Die Kantone müssen sich berühren (dürfen sich aber nicht überlappen): `st_touches()`\n- Die Kantone müssen innerhalb einer bestimmten Distanz zueinander liegen: `st_is_within_distance()`\n- Die Kantone müssen überlappen: `st_overlaps()`\n\nEgal für welche Variante Ihr Euch entscheidet, setzt `sparse = FALSE` damit eine Kreuzmatrix erstellt wird.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nw <- st_touches(zweitwohnung_kanton, sparse = FALSE)\n\nw[1:6, 1:6]\n##       [,1]  [,2]  [,3]  [,4]  [,5]  [,6]\n## [1,] FALSE FALSE FALSE FALSE  TRUE FALSE\n## [2,] FALSE FALSE  TRUE  TRUE FALSE  TRUE\n## [3,] FALSE  TRUE FALSE FALSE  TRUE  TRUE\n## [4,] FALSE  TRUE FALSE FALSE  TRUE  TRUE\n## [5,]  TRUE FALSE  TRUE  TRUE FALSE FALSE\n## [6,] FALSE  TRUE  TRUE  TRUE FALSE FALSE\n```\n:::\n\n\n(Lasst Euch nicht davon beirren, dass wir nun `TRUE` und `FALSE` statt `1` und `0` haben. In R sind `TRUE` und `1` äquivalent, sowie auch `FALSE` und `0`). \n\n\n::: {.cell}\n\n:::\n\n\nZur Überprüfung unserer Operation: Mit `w[1,]` bekommt  ihr ein Vektor, wo bei allen Kantone, die den ersten kanton (Zürich) berühren `TRUE` steht und bei allen anderen `FALSE`. Nun können wir überprüfen, ob die räumliche Operation funktioniert hat. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nberuehrt_1 <- w[1, ]\n\nggplot(zweitwohnung_kanton[beruehrt_1, ]) +\n  geom_sf(aes(fill = KANTONSNAME)) +\n  labs(title = \"Welche Kanton berühren den Kanton Zürich (st_touches)\")\n```\n\n::: {.cell-output-display}\n![](Rauman3_Uebung_A_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n:::\n\n\n\n\nDer nächste Teil sollte Euch nun bekannt vorkommen. Die Differenz aller Werte vom Mittelwert aller Werte $(y_i - \\bar{y})$ kennen wir schon vom ersten Bruch und haben wir auch bereits gelöst. Nun gilt es paarweise das Produkt der Abweichungen vom Mittelwert (die Covarianz) zu berechnen $(y_i - \\bar{y})(y_j - \\bar{y})$.  DAzu müssen wir *das Produkt aller Wertekombinationen* berechnen. Dies erreichen wir mit der Funktion `tcrossprod()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npm <- tcrossprod(dy)\npm[1:6,1:6]\n##               [,1]         [,2]          [,3]         [,4]         [,5]\n## [1,]  0.0008726497  0.001597812 -0.0006495424 -0.003249747 -0.001984912\n## [2,]  0.0015978120  0.002925576 -0.0011893051 -0.005950251 -0.003634352\n## [3,] -0.0006495424 -0.001189305  0.0004834762  0.002418896  0.001477437\n## [4,] -0.0032497469 -0.005950251  0.0024188956  0.012102055  0.007391811\n## [5,] -0.0019849120 -0.003634352  0.0014774366  0.007391811  0.004514842\n## [6,] -0.0023882557 -0.004372870  0.0017776588  0.008893862  0.005432280\n##              [,6]\n## [1,] -0.002388256\n## [2,] -0.004372870\n## [3,]  0.001777659\n## [4,]  0.008893862\n## [5,]  0.005432280\n## [6,]  0.006536145\n```\n:::\n\n\nNun multiplizieren wir die Covarianzen mit den Gewichten $w$ (Schalter), damit wir nur noch die Werte von den Kantonen haben, die auch effektiv benachbart sind (und eliminieren nicht-benachbarte Werte). Beachtet dass wir hier nun eine Matrix mit einer Matrix multiplizieren.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npmw <- pm * w\nw[1:6,1:6]\n##       [,1]  [,2]  [,3]  [,4]  [,5]  [,6]\n## [1,] FALSE FALSE FALSE FALSE  TRUE FALSE\n## [2,] FALSE FALSE  TRUE  TRUE FALSE  TRUE\n## [3,] FALSE  TRUE FALSE FALSE  TRUE  TRUE\n## [4,] FALSE  TRUE FALSE FALSE  TRUE  TRUE\n## [5,]  TRUE FALSE  TRUE  TRUE FALSE FALSE\n## [6,] FALSE  TRUE  TRUE  TRUE FALSE FALSE\npmw[1:6,1:6]\n##              [,1]         [,2]         [,3]         [,4]         [,5]\n## [1,]  0.000000000  0.000000000  0.000000000  0.000000000 -0.001984912\n## [2,]  0.000000000  0.000000000 -0.001189305 -0.005950251  0.000000000\n## [3,]  0.000000000 -0.001189305  0.000000000  0.000000000  0.001477437\n## [4,]  0.000000000 -0.005950251  0.000000000  0.000000000  0.007391811\n## [5,] -0.001984912  0.000000000  0.001477437  0.007391811  0.000000000\n## [6,]  0.000000000 -0.004372870  0.001777659  0.008893862  0.000000000\n##              [,6]\n## [1,]  0.000000000\n## [2,] -0.004372870\n## [3,]  0.001777659\n## [4,]  0.008893862\n## [5,]  0.000000000\n## [6,]  0.000000000\n```\n:::\n\n\nDen Zähler des ersten Bruches können wir nun fertig berechnen, indem wir die Summe aller gewichten (sprich eingeschalteten) Werten bilden:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nspmw <- sum(pmw, na.rm = TRUE)\nspmw\n## [1] 0.2007517\n```\n:::\n\n\n#### Nenner (Bruch 2)\n\nFür den Nenner des zweiten Teils der Formal (des zweiten Bruchs) müssen wir nun nur noch alle Gewichte summieren. Diese Summer entspricht der Anzahl effektiv benachbarter Kantone und kann Anzahl der $TRUE$-Werte in $w$ bestimmt werden. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nsmw <- sum(w, na.rm = TRUE)\n```\n:::\n\n\n#### Auflösung (Bruch 2)\n\nSo können wir den zweiten Bruch auflösen und berechnen:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsw  <- spmw / smw\n```\n:::\n\n\n### Auflösung der Formel\n\nDer allerletzte Schritt besteht darin, die Werte aus den beiden Brüche miteinander zu multiplizieren.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nMI <- vr * sw\nMI\n## [1] 0.3148631\n```\n:::\n\n\nDer Global Morans $I$ für die Abstimmungsdaten beträgt auf Kantonsebene also 0.3148631. Wie interpretiert ihr dieses Resultate? Was erwartet ihr für eine Resultat auf Gemeinde- oder Bezirksebene?\n\n## Aufgabe 2: Morans I für Gemeinde oder Bezirke berechnen\n\nNun könnt ihr Morans $I$ auf der Ebene der Gemeine oder Bezirke und untersuchen, ob und wie sich Morans $I$ verändert. Wenn ihr einen wenig leistungsfähigen Rechner habt, berechnet verwendet besser die Ebene \"Berzirke\". Importiert dazu den Layer `bezrik` oder `gemeinde` aus dem Datensatz `zweitwohnungsinitiative.gpkg`. Visualisiert in einem ersten Schritt die Abstimmungsresultate.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nzweitwohnung_gemeinde <- read_sf(\"datasets/rauman/zweitwohnungsinitiative.gpkg\", \"gemeinde\")\n\nggplot(zweitwohnung_gemeinde) +\n  geom_sf(aes(fill = ja_in_percent), colour = \"white\",lwd = 0.2) +\n  scale_fill_gradientn(\"Ja Anteil\",colours = RColorBrewer::brewer.pal(11, \"RdYlGn\"), limits = c(0,1)) +\n  theme(legend.position = \"bottom\")\n```\n\n::: {.cell-output-display}\n![](Rauman3_Uebung_A_files/figure-html/unnamed-chunk-19-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n:::",
    "supporting": [
      "Rauman3_Uebung_A_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}