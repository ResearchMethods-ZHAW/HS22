{
  "hash": "322a7b38b39021d881b3191405b72d72",
  "result": {
    "markdown": "---\ndate: 2022-11-28\nlesson: RaumAn1\nthema: Einführung\nindex: 1\n---\n\n\n# Rauman 1: Übung A\n\nEs gibt bereits eine Vielzahl von Packages um in R mit räumlichen Daten zu arbeiten, die ihrerseits wiederum auf weiteren Packages basieren (Stichwort `dependencies`). Für *Vektordaten* dominierte lange das Package [`sp`](https://cran.r-project.org/package=sp), welches nun durch [`sf`](https://r-spatial.github.io/sf/) abgelöst wurde. Wir werden wenn immer möglich mit `sf` arbeiten und nur in Ausnahmefällen auf andere Packages zurück greifen.\n\nFür die kommenden Übungen könnt ihr folgende Packages installieren bzw. laden:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(sf)\nlibrary(dplyr)\nlibrary(ggplot2)\n```\n:::\n\n\n## Aufgabe 1: Vektor Daten runterladen und importieren\n\nLade zunächst die Datensätze unter folgenden Links herunter:\n\n- [kantone.gpkg](https://moodle.zhaw.ch/mod/resource/view.php?id=602275)\n- [gemeinden.gpkg](https://moodle.zhaw.ch/mod/resource/view.php?id=602276)\n\nEs handelt sich um Geodatensätze im Format Geopackage (\"\\*.gpkg\"), eine alternatives Datenformat zum bekannteren Format \"Shapefiles\". Importiere die Datensätze wie folgt:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nkantone <- read_sf(\"data/kantone.gpkg\")\ngemeinden <- read_sf(\"data/gemeinden.gpkg\") \n```\n:::\n\n\nSchau Dir die importierten Datensätze an. Am meisten Informationen zu `sf` Objekten bekommst du, wenn du dir den Datensatz **in der Konsole** anschaust (in dem du den Variabel-Name in der Konsole eintippst). Mit dem RStudio Viewer werden `sf` Objekte nur sehr langsam geladen und die Metadaten werden nicht angezeigt.\n\n## Aufgabe 2: Daten Visualisieren\n\nVektordaten (`sf` Objekte) lassen sich teilweise sehr schön in die bekannten Tidyverse workflows integrieren. Das merkt man schnell, wenn man die Daten visualisieren möchte. In InfoVis 1 & 2 haben wir intensiv mit `ggplot2` gearbeitet und dort die Layers `geom_point()` und `geom_line()` kennen gelernt. Zusätzlich beinhaltet `ggplot` die Möglichkeit, mit `geom_sf()` Vektordaten direkt und sehr einfach zu plotten. Die nachfolgende Aufgabe werden wir aber mit `plot` abbilden (Warum wird gleich erläutert). Führe die angegebenen R-Befehle aus und studiere die entstehenden Plots. Welche Unterschiede findest Du? Wie erklärst Du diese Unterschiede?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(gemeinden, max.plot = 1)\n\nplot(kantone, max.plot = 1)\n```\n\n::: {.cell-output-display}\n![Generierter Plot](Rauman1_Uebung_A_files/figure-html/fig-baseplot-ex2-1.png){#fig-baseplot-ex2-1 width=672}\n:::\n\n::: {.cell-output-display}\n![Generierter Plot](Rauman1_Uebung_A_files/figure-html/fig-baseplot-ex2-2.png){#fig-baseplot-ex2-2 width=672}\n:::\n:::\n\n\n## Input: Koodinatensysteme\n\nIn der obigen visualierung fällt folgendes auf:\n\n- die X/Y Achsen weisen zwei ganz unterschiedlichen Zahlenbereiche auf (vergleiche die Achsenbeschriftungen)\n- der Umriss der Schweiz sieht in den beiden Datensätzen unterschiedlich aus (`kantone` ist gegenüber `gemeinden` gestaucht)\n\nDies hat natürlich damit zu tun, dass die beiden Datensätze in unterschiedlichen Koordinatensystemen erfasst wurden. Koordinatensysteme werden mit CRS (**C**oordinate **R**eference **S**ystem) abgekürzt. Mit `st_crs()` können die zugewiesenen Koordinatensysteme abgefragt werden.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nst_crs(kantone)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCoordinate Reference System: NA\n```\n:::\n\n```{.r .cell-code}\nst_crs(gemeinden)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCoordinate Reference System: NA\n```\n:::\n:::\n\n\nLeider sind in unserem Fall keine Koordinatensysteme zugewiesen. Mit etwas Erfahrung kann man das Koordinatensystem aber erraten, so viele kommen nämlich gar nicht in Frage. Am häufigsten trifft man hierzulande eines der drei folgenden Koordinatensysteme an:\n\n- [CH1903 LV03](https://epsg.io/21781): das alte Koordinatensystem der Schweiz\n- [CH1903+ LV95](https://epsg.io/2056): das neue Koordinatensystem der Schweiz\n- [WGS84](https://epsg.io/4326): ein häufig genutztes weltumspannendes geodätisches Koordinatensystem, sprich die Koordinaten werden in Länge und Breite angegeben (Lat/Lon).\n\nNun gilt es, anhand der Koordinaten die in der Spalte `geometry` ersichtlich sind das korrekte Koordinatensystem festzustellen. Wenn man sich auf [epsg.io/map](https://epsg.io/map#srs=4326&x=8.407288&y=46.773731&z=9&layer=streets) die Schweiz anschaut, kann man die Koordinaten in verschiedenen Koordinatensystem betrachten.\n\n**Bedienungshinweise**:\n\n<fig>\n<img src = \"images/koordinatenpaar.jpg\" width = 50%>\n<figcaption>Koordinanten (des Fadenkreuzes) werden im ausgewählten Koordinatensystem dargestellt</figcaption>\n</fig>\n\n<fig>\n<img src = \"images/koordinatensystem.jpg\" width = 50%>\n<figcaption>Das Koordinatensystem, in welchem die Koordinaten dargestellt werden sollen, kann mit \"Change\" angepasst werden</figcaption>\n</fig>\n\n<fig>\n<img src = \"images/reproject.jpg\" width = 50%>\n<figcaption>Für Enthusiasten: Schau Dir die Schweiz in verschiedenen Koordinatensystemen an, in dem Du auf \"Reproject Map\" klickst</figcaption>\n</fig>\n\nWenn man diese Koordinaten mit den Koordinaten unserer Datensätze vergleicht, dann ist schnell klar, dass es sich beim Datensatz `kantone` um das Koordinatensystem WGS84 handelt und bei `gemeinden` das Koordinatensystem CH1903+ LV95. Diese Koordinatensyteme weisen wir nun mit `st_set_crs()` und dem entsprechenden *EPSG*-Code (siehe die jeweiligen Links) zu.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nkantone <- st_set_crs(kantone, 4326)\ngemeinden <- st_set_crs(gemeinden, 2056)\n\n# zuweisen mit st_set_crs(), abfragen mit st_crs()\nst_crs(kantone)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCoordinate Reference System:\n  User input: EPSG:4326 \n  wkt:\nGEOGCRS[\"WGS 84\",\n    DATUM[\"World Geodetic System 1984\",\n        ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n            LENGTHUNIT[\"metre\",1]]],\n    PRIMEM[\"Greenwich\",0,\n        ANGLEUNIT[\"degree\",0.0174532925199433]],\n    CS[ellipsoidal,2],\n        AXIS[\"geodetic latitude (Lat)\",north,\n            ORDER[1],\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        AXIS[\"geodetic longitude (Lon)\",east,\n            ORDER[2],\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n    USAGE[\n        SCOPE[\"unknown\"],\n        AREA[\"World\"],\n        BBOX[-90,-180,90,180]],\n    ID[\"EPSG\",4326]]\n```\n:::\n:::\n\n\nAuch wenn das CRS der Datensätze bekannt ist, nutzt ggplot immer noch `EPSG 4326` um die Achsen zu beschriften.  Wenn das stört, kann man `coord_sf(datum = 2056)` in einem weiteren Layer spezifizieren. Oder aber man blendet die Achsenbeschriftung mit `theme_void()` komplett aus. Versuche beide Varianten.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot() + \n  geom_sf(data = kantone) +\n  coord_sf(datum = 2056)\n```\n\n::: {.cell-output-display}\n![Generierter Plot](Rauman1_Uebung_A_files/figure-html/fig-ggplot-ex2-1.png){#fig-ggplot-ex2 width=672}\n:::\n:::\n\n\n## Aufgabe 3: Koordinatensyteme *transformieren*\n\nIn der vorherigen Übung haben wir das bestehende Koordinatensystem *zugewiesen*. Dabei haben wir die bestehenden Koordinaten (in der Spalte `geom`) *nicht* manipuliert. Ganz anders ist eine *Transformation* der Daten von einem Koordinatensystem in das andere. Bei einer Transformation werden die Koordinaten in das neue Koordinatensystem umgerechnet und somit manipuliert. Aus praktischen Gründen wollen <!-- Was sind diese Gründe? genauer erläutern? -->\nwir all unsere Daten ins neue Schweizer Koordinatensystem CH1903+ LV95 transfomieren. Transformiere den Datensatz `kantone` mit `st_transform()`in CH1903+ LV95, nutze dafür den korrekten EPSG-Code.\n\nVor der Transformation (betrachte die Attribute `Bounding box` sowie `Geodetic CRS`): \n\n\n::: {.cell}\n\n```{.r .cell-code}\nkantone\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSimple feature collection with 51 features and 6 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 5.955902 ymin: 45.81796 xmax: 10.49217 ymax: 47.80845\nGeodetic CRS:  WGS 84\n# A tibble: 51 × 7\n   NAME       KANTON…¹ SEE_F…² KANTO…³ KT_TEIL EINWO…⁴                      geom\n * <chr>         <int>   <dbl>   <dbl> <chr>     <int>             <POLYGON [°]>\n 1 Graubünden       18      NA  710530 0        197888 ((8.877053 46.81291, 8.8…\n 2 Bern              2   11897  595952 1       1031126 ((7.153522 46.98628, 7.1…\n 3 Valais           23    1060  522463 0        341463 ((8.477625 46.52762, 8.4…\n 4 Vaud             22   39097  321201 1        793129 ((6.779825 46.85296, 6.7…\n 5 Ticino           21    7147  281216 0        353709 ((8.477625 46.52762, 8.4…\n 6 St. Gallen       17    7720  202820 1        504686 ((8.808609 47.22009, 8.7…\n 7 Zürich            1    6811  172894 0       1504346 ((8.410084 47.24837, 8.4…\n 8 Fribourg         10    7818  167142 1        315074 ((7.040344 46.97952, 7.0…\n 9 Luzern            3    6438  149352 0        406506 ((8.468167 46.99652, 8.4…\n10 Aargau           19     870  140380 1        670988 ((8.410084 47.24837, 8.4…\n# … with 41 more rows, and abbreviated variable names ¹​KANTONSNUM, ²​SEE_FLAECH,\n#   ³​KANTONSFLA, ⁴​EINWOHNERZ\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nkantone <- st_transform(kantone, 2056)\n```\n:::\n\n\nNach der Transformation (betrachte die Attribute `Bounding box` sowie `Projected CRS`):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nkantone\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSimple feature collection with 51 features and 6 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 5.955902 ymin: 45.81796 xmax: 10.49217 ymax: 47.80845\nGeodetic CRS:  WGS 84\n# A tibble: 51 × 7\n   NAME       KANTON…¹ SEE_F…² KANTO…³ KT_TEIL EINWO…⁴                      geom\n * <chr>         <int>   <dbl>   <dbl> <chr>     <int>             <POLYGON [°]>\n 1 Graubünden       18      NA  710530 0        197888 ((8.877053 46.81291, 8.8…\n 2 Bern              2   11897  595952 1       1031126 ((7.153522 46.98628, 7.1…\n 3 Valais           23    1060  522463 0        341463 ((8.477625 46.52762, 8.4…\n 4 Vaud             22   39097  321201 1        793129 ((6.779825 46.85296, 6.7…\n 5 Ticino           21    7147  281216 0        353709 ((8.477625 46.52762, 8.4…\n 6 St. Gallen       17    7720  202820 1        504686 ((8.808609 47.22009, 8.7…\n 7 Zürich            1    6811  172894 0       1504346 ((8.410084 47.24837, 8.4…\n 8 Fribourg         10    7818  167142 1        315074 ((7.040344 46.97952, 7.0…\n 9 Luzern            3    6438  149352 0        406506 ((8.468167 46.99652, 8.4…\n10 Aargau           19     870  140380 1        670988 ((8.410084 47.24837, 8.4…\n# … with 41 more rows, and abbreviated variable names ¹​KANTONSNUM, ²​SEE_FLAECH,\n#   ³​KANTONSFLA, ⁴​EINWOHNERZ\n```\n:::\n:::\n\n\n## Aufgabe 4: Chloroplethen Karte\n\nNun wollen wir die Gemeinden respektive die Kantone nach ihrer Einwohnerzahl einfärben. Dafür verwenden wir wie gewohnt die Methode `aes(fill = ...)` von `ggplot`. \n\nTips: \n\n- um die *scientific notation* (z.B. `3e+03`) zu verhindern, könnt ihr den Befehl `options(scipen = 999)` ausführen\n- um die Darstellung der Gemeinde- (bzw. Kantons-) Grenzen zu verhindern, könnt ihr im entsprechenden Layer `color = NA` setzen. Alternativ könnt ihr die Linienbreite mit `size = ` verändern.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(kantone, aes(fill = EINWOHNERZ/1e6)) +\n  geom_sf(color= \"white\",size = .05) +\n  labs(title = \"Anzahl Einwohner pro Kanton\",\n       subtitle = \"in Millionen\") +\n  theme(legend.position = \"bottom\",\n        legend.title = element_blank(),\n        legend.key.width = unit(0.15, 'npc'),\n        legend.key.height = unit(0.02, 'npc'),\n        legend.text = element_text(angle = 90,hjust = 0.5),\n        legend.text.align = 1)\n\nggplot(gemeinden,aes(fill = EINWOHNERZ/1e6)) +\n  geom_sf(color= \"white\",size = .05) +\n  scale_fill_continuous(\"Einwohner (in Mio)\") +\n  labs(title = \"Anzahl Einwohner pro Gemeinde\",\n       subtitle = \"in Millionen\") +\n  theme(legend.position = \"bottom\",\n        legend.title = element_blank(),\n        legend.key.width = unit(0.15, 'npc'),\n        legend.key.height = unit(0.02, 'npc'),\n        legend.text = element_text(angle = 90,hjust = 0.5),\n        legend.text.align = 1)\n```\n\n::: {.cell-output-display}\n![Der Vergleich dieser beiden Darstellungen veranschaulicht die MAUP Problematik sehr deutlich](Rauman1_Uebung_A_files/figure-html/fig-ggplot-ex4-1.png){#fig-ggplot-ex4-1 width=49%}\n:::\n\n::: {.cell-output-display}\n![Der Vergleich dieser beiden Darstellungen veranschaulicht die MAUP Problematik sehr deutlich](Rauman1_Uebung_A_files/figure-html/fig-ggplot-ex4-2.png){#fig-ggplot-ex4-2 width=49%}\n:::\n:::\n\n",
    "supporting": [
      "Rauman1_Uebung_A_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}