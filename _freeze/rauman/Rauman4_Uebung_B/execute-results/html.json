{
  "hash": "30772e351eeff60914400fd856923485",
  "result": {
    "markdown": "---\ndate: 2022-12-06\nlesson: RaumAn4\nthema: Einführung Rasterdaten\nindex: 2\n---\n\n\n# Rauman 4: Übung B\n\nEiner der wichtigsten Aspekte der bevorstehenden Übung (Multi-Criteria Evaluation (MCE)) ist die Verwendung und Bearbeitung von **Rasterdatensätzen**. In \"R\" werden hauptsächlich zwei Pakete zur Bearbeitung von Rasterdaten verwendet: `terra` und das Paket `raster`. Das letztere wird immer noch stark genutzt, wird aber unweigerlich durch das erstere ersetzt.\n\nIm dieser Übung werden wir `terra` verwenden, um zu zeigen, wie wir einen Rasterdatensatz importieren können. Unter dem untenstehenden Link können Sie eine tif-Datei herunterladen, die das \"Digitale Höhenmodell\" (DHM)* des Kantons Schwyz in der Schweiz darstellt. Laden Sie den Datensatz herunter und führen Sie den angegebenen Code aus.\n\nDatensatz: [dhm25m.tif](https://moodle.zhaw.ch/mod/resource/view.php?id=602285)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(terra)\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in library(terra): es gibt kein Paket namens 'terra'\n```\n:::\n:::\n\n\nImportieren Sie Ihr Raster mit der Funktion `rast`\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndhm_schwyz <- rast(\"datasets/rauman/dhm25m.tif\")\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in rast(\"datasets/rauman/dhm25m.tif\"): konnte Funktion \"rast\" nicht finden\n```\n:::\n:::\n\n\nSie erhalten einige wichtige Metadaten über den Rasterdatensatz, wenn Sie den Variablennamen in die Konsole eingeben.  \n\n\n::: {.cell}\n\n```{.r .cell-code}\ndhm_schwyz \n```\n\n::: {.cell-output .cell-output-error}\n```\nError in eval(expr, envir, enclos): Objekt 'dhm_schwyz' nicht gefunden\n```\n:::\n:::\n\n\nUm einen schnellen Überblick eines Rasterdatensatz zu erhalten, können wir einfach die `plot()` Funktion verwenden.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(dhm_schwyz)\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in plot(dhm_schwyz): Objekt 'dhm_schwyz' nicht gefunden\n```\n:::\n:::\n\n\nLeider ist das Verwenden von `Rastern` in ggplot nicht sehr einfach. Da `ggplot` ein universelles Plot-Framework ist, stossen wir schnell an die Grenzen des Möglichen, wenn wir etwas so Spezielles wie Karten erstellen. Aus diesem Grund werden wir ein neues Plot-Framework einführen, das auf Karten spezialisiert ist und in einem sehr ähnlichen Design wie ggplot gebaut wurde: `tmap`. Installieren und laden Sie dieses Paket jetzt.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tmap)\n```\n\n::: {.cell-output .cell-output-error}\n```\nError: Laden von Paket oder Namensraum für 'tmap' in loadNamespace(i, c(lib.loc, .libPaths()), versionCheck = vI[[i]]): fehlgeschlagen\n es gibt kein Paket namens 'terra'\n```\n:::\n:::\n\n\nGenau wie `ggplot` basiert `tmap` auf der Idee von \"Ebenen\", die durch ein `+` verbunden sind. Jede Ebene hat zwei Komponenten:\n\n- eine Datensatzkomponente, die immer `tm_shape(dataset)` ist (ersetzen Sie `dataset` durch Ihre Variable)\n- eine Geometriekomponente, die beschreibt, wie das vorangegangene `tm_shape()` visualisiert werden soll. Dies kann `tm_dots()` für Punkte, `tm_polygons()` für Polygone, `tm_lines()` für Linien usw. sein. Für Einzelbandraster (was bei `dhm_schwyz` der Fall ist) ist es `tm_raster()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(dhm_schwyz) + \n  tm_raster() \n```\n\n::: {.cell-output .cell-output-error}\n```\nError in tm_shape(dhm_schwyz): konnte Funktion \"tm_shape\" nicht finden\n```\n:::\n:::\n\n\nBeachten Sie, dass `tm_shape()` und `tm_raster()` (in diesem Fall) zusammengehören. Das eine kann nicht ohne das andere leben.\n\nWenn Sie die Hilfe von `?tm_raster` konsultieren, werden Sie eine Vielzahl von Optionen sehen, mit denen Sie die Visualisierung Ihrer Daten verändern können. Zum Beispiel ist der Standardstil von `tm_raster()` die Erstellung von \"Bins\" mit einer diskreten Farbskala. Wir können dies mit `style = \"cont\"` ausser Kraft setzen.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(dhm_schwyz) + \n  tm_raster(style = \"cont\") \n```\n\n::: {.cell-output .cell-output-error}\n```\nError in tm_shape(dhm_schwyz): konnte Funktion \"tm_shape\" nicht finden\n```\n:::\n:::\n\n\nDas sieht schon ziemlich toll aus, aber vielleicht wollen wir die Standard-Farbpalette ändern. Glücklicherweise ist das in `tmap` viel einfacher als in `ggplot2`. Um sich die verfügbaren Paletten anzusehen, geben Sie `tmaptools::palette_explorer()` oder `RColorBrewer::display.brewer.all()` in der Konsole ein (für Ersteres müssen Sie möglicherweise zusätzliche Pakete installieren, z.B. `shinyjs`).\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(dhm_schwyz) + \n  tm_raster(style = \"cont\", palette = \"Spectral\") \n```\n\n::: {.cell-output .cell-output-error}\n```\nError in tm_shape(dhm_schwyz): konnte Funktion \"tm_shape\" nicht finden\n```\n:::\n:::\n\n\nSie können Layout-Anpassungen mit `tm_layout()` vornehmen, prüfen Sie `?tm_layout`, um alle verfügbaren Optionen zu sehen.\n\n::: {.column-body}\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(dhm_schwyz) + \n  tm_raster(style = \"cont\", palette = \"Spectral\", legend.is.portrait = FALSE, title = \"\") +\n  tm_layout(legend.outside = TRUE, legend.outside.position = \"bottom\",frame = FALSE)\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in tm_shape(dhm_schwyz): konnte Funktion \"tm_shape\" nicht finden\n```\n:::\n:::\n\n:::\n\n\n\n## Aufgabe 1\n\nMit `terra` können wir eine Vielzahl von Rasteroperationen über unser Höhenmodell laufen lassen. Eine klassische Rasteroperation ist zum Beispiel das Berechnenen der Hangneigung oder dessen Orientierung. Nutzen Sie die Funktion `terrain()` aus `terra` um die Hangneigung und Orientierung zu berechnen. Visualisieren Sie die Resultate.\n\n\n::: {.cell}\n::: {.cell-output .cell-output-error}\n```\nError in terrain(dhm_schwyz, \"slope\"): konnte Funktion \"terrain\" nicht finden\n```\n:::\n\n::: {.cell-output .cell-output-error}\n```\nError in terrain(dhm_schwyz, \"aspect\"): konnte Funktion \"terrain\" nicht finden\n```\n:::\n:::\n\n\n\n## Aufgabe 2\n\nMit Hangneigung und -ausrichtung können wir einen *Hillshading*-Effekt berechnen. Hillshading bedeutet, dass der Schattenwurf des Oberflächenmodells bei gegebenen Einfallswinkel der Sonne (Höhe und Azimut) berechnet wird. Der typische Einfallswinkel liegt bei 45° über dem Horizont und von Nordwesten bei 315°.\n\nUm einen Hillshading Effekt zu erzeugen, berechne zuerst `slope` und `aspect` von `dhm_schwyz` analog der letzten Aufgabe, achte aber darauf das die Einheit `radians` entspricht. Nutze diese beiden Objekte um den Hillshade zu berechnen. Visualisiere den Output anschliessend mit `plot` oder `tmap`.\n\n\n::: {.cell}\n::: {.cell-output .cell-output-error}\n```\nError in terrain(dhm_schwyz, \"slope\", unit = \"radians\"): konnte Funktion \"terrain\" nicht finden\n```\n:::\n\n::: {.cell-output .cell-output-error}\n```\nError in terrain(dhm_schwyz, \"aspect\", unit = \"radians\"): konnte Funktion \"terrain\" nicht finden\n```\n:::\n\n::: {.cell-output .cell-output-error}\n```\nError in shade(dhm_slope, dhm_aspect, 45, 315): konnte Funktion \"shade\" nicht finden\n```\n:::\n\n::: {.cell-output .cell-output-error}\n```\nError in tm_shape(dhm_hillshade): konnte Funktion \"tm_shape\" nicht finden\n```\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}