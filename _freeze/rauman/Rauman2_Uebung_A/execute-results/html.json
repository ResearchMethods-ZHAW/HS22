{
  "hash": "f114333e2f74f5343ce59cae2b2164c9",
  "result": {
    "markdown": "---\ndate: 2022-11-29\nlesson: RaumAn2\nthema: G-Funktion\nindex: 1\n---\n\n\n# Rauman 2: Übung A\n\n  <!-- In dieser zweiten Übung wirst Du wiederum Geodatensätze verarbeiten und darstellen. Wir starten mit einem Punktdatensatz zu einem Messnetz zur Erhebung der Luftqualität in der Schweiz (Stickstoffdioxid NO2 um genau zu sein). Im Gegensatz zum Punktdatensatz zur Wasserverfügbarkeit aus der vorherigen Übung, sind die Messstellen des Messnetzes zur Luftqualität sehr unregelmässig im Raum verteilt. Trotzdem möchten wir versuchen ein kontinuierliches Raster von Luftqualitätswerten für die ganze Schweiz zu interpolieren. Wir starten mit der einfachen Interpolations-Methode Inverse Distance Weighting IDW. Danach wollen wir für den gleichen Datensatz nach dem Ansatz der nächsten Nachbarn die Thiessen Polygone konstruieren. Im zweiten Teil der Übung wollen wir Dichteverteilung untersuchen. Dabei untersuchen wir einen Datensatz mit Bewegungsdaten eines Rotmilans in der Schweiz. Mittels einer Kernel Density Estimation (KDE) berechnen wir eine kontinuierliche Dichteverteilung, über die wir eine Annäherung an das Habitat des untersuchten Greifvogels berechnen können. Bevor wir aber starten, schauen wir uns die Punktdatensätze genauer an indem wir die G-Function berechnen und plotten. \n-->\n\n## Aufgabe 1\n\nFür die heutige Übung benötigen wir nachstehende Datensätze. Lade diese herunter und importiere sie in R. Prüfe, ob das CRS korrekt gesetzt wurde, setze es wenn nötig. Mache dich mit den Daten vertraut (visualieren, durchscrollen usw).\n\n\n::: {.cell}\n\n:::\n\n\n- Der Datensatz [rotmilan.gpkg](https://moodle.zhaw.ch/mod/resource/view.php?id=602279) stammt aus einem grösseren Forschungsprojekt der Vogelwarte Sempach [Mechanismen der Populationsdynamik beim Rotmilan](https://www.vogelwarte.ch/de/projekte/oekologische-forschung/mechanismen-der-populationsdynamik-beim-rotmilan). Der Datensatz wurde über die Plattform [movebank](http://www.movebank.org/panel_embedded_movebank_webapp?gwt_fragment=page%3Dsearch_map_linked%2CindividualIds%3D676571254%2Clat%3D44.465151013519666%2Clon%3D9.096679687499508%2Cz%3D5) zur Verfügung gestellt. Es handelt sich dabei um ein einzelnes Individuum, welches seit 2017 mit einem Sender versehen ist und über ganz Mitteleuropa zieht. Wir arbeiten in dieser Übung nur mit denjenigen Datenpunkten, die in der Schweiz erfasst wurden. Wer den ganzen Datensatz analysieren möchte, kann sich diesen über den Movebank-Link runterladen.\n- Der Datensatz [luftqualitaet.gpkg](https://moodle.zhaw.ch/mod/resource/view.php?id=602280) beinhaltet Messungen von Stickstoffdioxid $NO_2$ aus dem Jahr 2015 für 97 Messstellen in der Schweiz. Stickstoffdioxid entstehen beim Verbrennen von Brenn- und Treibstoffen, insbesondere bei hohen Verbrennungstemperaturen, wobei der Strassenverkehr als Hauptquelle gilt. \nMehr Informationen dazu findet ihr [hier](https://www.bafu.admin.ch/bafu/de/home/themen/thema-luft/luft--daten--indikatoren-und-karten/luft--indikatoren/indikator-luft.pt.html/aHR0cHM6Ly93d3cuaW5kaWthdG9yZW4uYWRtaW4uY2gvUHVibG/ljL0FlbURldGFpbD9pbmQ9TFUwMjAmbG5nPWRlJlN1Ymo9Tg%3d%3d.html).\n- Ebenfalls benötigt ihr den Datensatz [schweiz.gpkg](https://moodle.zhaw.ch/mod/resource/view.php?id=602281)\n\n\n::: {.cell}\n::: {.cell-output .cell-output-error}\n```\nError: Cannot open \"data/rotmilan.gpkg\"; The file doesn't seem to exist.\n```\n:::\n\n::: {.cell-output .cell-output-error}\n```\nError: Cannot open \"data/schweiz.gpkg\"; The file doesn't seem to exist.\n```\n:::\n\n::: {.cell-output .cell-output-error}\n```\nError: Cannot open \"data/luftqualitaet.gpkg\"; The file doesn't seem to exist.\n```\n:::\n:::\n\n::: {.cell}\n::: {.cell-output .cell-output-error}\n```\nError in ggplot(rotmilan): Objekt 'rotmilan' nicht gefunden\n```\n:::\n:::\n\n\n## Aufgabe 2\n\nAls erstes berechnen wir die G-Function für die Rotmilanpositionen:\n\n### Schritt 1\n\nMit `st_distance()` können Distanzen zwischen zwei `sf` Datensätze berechnet werden. Wird nur ein Datensatz angegeben, wird eine Kreuzmatrix erstellt wo die Distanzen zwischen allen Features zu allen anderen Features dargestellt werden. Wir nützen diese Funktion zur Berechnung der nächsten Nachbarn.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrotmilan_distanzmatrix <- st_distance(rotmilan)\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in st_distance(rotmilan): Objekt 'rotmilan' nicht gefunden\n```\n:::\n\n```{.r .cell-code}\nnrow(rotmilan_distanzmatrix)\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in nrow(rotmilan_distanzmatrix): Objekt 'rotmilan_distanzmatrix' nicht gefunden\n```\n:::\n\n```{.r .cell-code}\nncol(rotmilan_distanzmatrix)\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in ncol(rotmilan_distanzmatrix): Objekt 'rotmilan_distanzmatrix' nicht gefunden\n```\n:::\n\n```{.r .cell-code}\n# zeige die ersten 6 Zeilen und Spalten der Matrix\n# jeder Wert ist 2x vorhanden (vergleiche Wert [2,1] mit [1,2])\n# die Diagonale ist die Distanz zu sich selber (gleich 0)\nrotmilan_distanzmatrix[1:6,1:6] \n```\n\n::: {.cell-output .cell-output-error}\n```\nError in eval(expr, envir, enclos): Objekt 'rotmilan_distanzmatrix' nicht gefunden\n```\n:::\n:::\n\n\n### Schritt 2\n\nNun wollen wir wissen, wie gross die *kürzeste* Distanz von jedem Punkt zu seinem nächsten Nachbarn beträgt, also die *kürzeste Distanz pro Zeile*. Bevor wir diese ermitteln müssen wir die diagonalen Werte noch entfernen, denn diese stellen ja jeweils die Distanz zu sich selber dar und sind immer `0`. Danach kann mit `apply()` eine Funktion (`FUN = min`) über die Zeilen (`MARGIN = 1`) einer Matrix (`X = rotmilan_distanzmatrix`) gerechnet werden. Zusätzlich müssen wir noch `na.rm = TRUE` setzen, damit `NA` Werte von der Berechnung ausgeschlossen werden. Das Resultat ist ein Vektor mit gleich vielen Werten wie Zeilen in der Matrix.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndiag(rotmilan_distanzmatrix) <- NA # entfernt alle diagonalen Werte\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in diag(rotmilan_distanzmatrix) <- NA: Objekt 'rotmilan_distanzmatrix' nicht gefunden\n```\n:::\n\n```{.r .cell-code}\nrotmilan_distanzmatrix[1:6,1:6] \n```\n\n::: {.cell-output .cell-output-error}\n```\nError in eval(expr, envir, enclos): Objekt 'rotmilan_distanzmatrix' nicht gefunden\n```\n:::\n\n```{.r .cell-code}\nrotmilan_mindist <- apply(rotmilan_distanzmatrix,1,min, na.rm = TRUE)\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in apply(rotmilan_distanzmatrix, 1, min, na.rm = TRUE): Objekt 'rotmilan_distanzmatrix' nicht gefunden\n```\n:::\n:::\n\n\n### Schritt 3\n\nNun müssen wir die Distanzen nach ihrer Grösse sortieren \n\n\n::: {.cell}\n\n```{.r .cell-code}\nrotmilan_mindist <- sort(rotmilan_mindist) \n```\n\n::: {.cell-output .cell-output-error}\n```\nError in sort(rotmilan_mindist): Objekt 'rotmilan_mindist' nicht gefunden\n```\n:::\n:::\n\n\n### Schritt 4\n\nJetzt berechnen wir die kummulierte Häufigkeit von jeder Distanz berechnen. Die kummulierte Häufikgeit vom ersten Wert ist 1 (der Index des ersten Wertes) dividiert durch die Anzahl Werte insgesamt. Mit `seq_along` erhalten wir die Indizes aller Werte, mit `lenth` die Anzahl Werte insgesamt.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nkumm_haeufgikeit <- seq_along(rotmilan_mindist) / length(rotmilan_mindist)\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in eval(expr, envir, enclos): Objekt 'rotmilan_mindist' nicht gefunden\n```\n:::\n:::\n\n\n### Schritt 5\n\nNun wollen wir die kumulierte Häufigkeit der Werte in einer Verteilungsfunktion (engl: [Empirical Cumulative Distribution Function, ECDF](https://en.wikipedia.org/wiki/Empirical_distribution_function)) darstellen. Dafür müssen wir die beiden Vektoren zuerst noch in einen Dataframe packen, damit `ggplot` damit klar kommt. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nrotmilan_mindist_df <- data.frame(distanzen = rotmilan_mindist,\n                                  kumm_haeufgikeit = kumm_haeufgikeit)\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in data.frame(distanzen = rotmilan_mindist, kumm_haeufgikeit = kumm_haeufgikeit): Objekt 'rotmilan_mindist' nicht gefunden\n```\n:::\n\n```{.r .cell-code}\np <- ggplot() + \n  geom_line(data = rotmilan_mindist_df, aes(distanzen, kumm_haeufgikeit)) +\n  labs(x = \"Distanz (Meter)\", y = \"Häufigkeit (kummuliert)\")\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in fortify(data): Objekt 'rotmilan_mindist_df' nicht gefunden\n```\n:::\n\n```{.r .cell-code}\np\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in eval(expr, envir, enclos): Objekt 'p' nicht gefunden\n```\n:::\n:::\n\n\nLesehilfe:\n\n\n::: {.cell}\n::: {.cell-output .cell-output-error}\n```\nError in sort(x): Objekt 'rotmilan_mindist_df' nicht gefunden\n```\n:::\n\n::: {.cell-output .cell-output-error}\n```\nError in sort(x): Objekt 'rotmilan_mindist_df' nicht gefunden\n```\n:::\n\n::: {.cell-output .cell-output-error}\n```\nError in eval(expr, envir, enclos): Objekt 'p' nicht gefunden\n```\n:::\n:::\n\n\n## Aufgabe 3\n\nFühre nun die gleichen Schritte mit `luftqualitaet` durch und vergleiche die ECDF-Plots. \n\n\n::: {.cell}\n::: {.cell-output .cell-output-error}\n```\nError in st_distance(luftqualitaet): Objekt 'luftqualitaet' nicht gefunden\n```\n:::\n\n::: {.cell-output .cell-output-error}\n```\nError in diag(luftqualitaet_distanzmatrix) <- NA: Objekt 'luftqualitaet_distanzmatrix' nicht gefunden\n```\n:::\n\n::: {.cell-output .cell-output-error}\n```\nError in apply(luftqualitaet_distanzmatrix, 1, min, na.rm = TRUE): Objekt 'luftqualitaet_distanzmatrix' nicht gefunden\n```\n:::\n\n::: {.cell-output .cell-output-error}\n```\nError in sort(luftqualitaet_mindist): Objekt 'luftqualitaet_mindist' nicht gefunden\n```\n:::\n\n::: {.cell-output .cell-output-error}\n```\nError in eval(expr, envir, enclos): Objekt 'luftqualitaet_mindist' nicht gefunden\n```\n:::\n\n::: {.cell-output .cell-output-error}\n```\nError in data.frame(distanzen = luftqualitaet_mindist, kumm_haeufgikeit = kumm_haeufgikeit_luftquali): Objekt 'luftqualitaet_mindist' nicht gefunden\n```\n:::\n\n::: {.cell-output .cell-output-error}\n```\nError in luftqualitaet_mindist_df$data <- \"Luftqualitaet\": Objekt 'luftqualitaet_mindist_df' nicht gefunden\n```\n:::\n\n::: {.cell-output .cell-output-error}\n```\nError in rotmilan_mindist_df$data <- \"Rotmilan\": Objekt 'rotmilan_mindist_df' nicht gefunden\n```\n:::\n\n::: {.cell-output .cell-output-error}\n```\nError in rbind(luftqualitaet_mindist_df, rotmilan_mindist_df): Objekt 'luftqualitaet_mindist_df' nicht gefunden\n```\n:::\n\n::: {.cell-output .cell-output-error}\n```\nError in ggplot(mindist_df, ): Objekt 'mindist_df' nicht gefunden\n```\n:::\n:::\n\n\n## Musterlösung\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}